<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —à—É–º–∞</title>
  <style>
    :root {
      --bg-color: #222;
      --card-bg: #333;
      --text-color: #ffffff;
      --accent-color: #1465ac;
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      --border-radius: 12px;
    }

    body {
      background: var(--bg-color);
      color: var(--text-color);
      font-family: -apple-system, BlinkMacSystemFont, 'system-ui', sans-serif;
      margin: 0;
      padding: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      overflow-y: auto;
      box-sizing: border-box;
    }

    .container {
      max-width: 1200px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 16px;
      max-height: 100vh;
      box-sizing: border-box;
    }

    .canvas-container {
      position: relative;
      width: 100%;
      display: flex;
      justify-content: center;
    }

    canvas {
      border: 1px solid #555;
      border-radius: var(--border-radius);
      max-height: calc(100vh - 320px);
      width: 100%;
      object-fit: contain;
      background: #000;
      box-shadow: var(--shadow);
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      padding: 12px;
      background: var(--card-bg);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
      position: relative;
    }

    label {
      font-size: 14px;
      font-weight: 500;
      opacity: 0.9;
    }

    input[type="number"],
    select,
    input[type="checkbox"],
    input[type="color"] {
      background: #666;
      border: none;
      border-radius: 8px;
      padding: 8px;
      color: var(--text-color);
      font-size: 14px;
      transition: background 0.2s;
      width: 100%;
      box-sizing: border-box;
    }

    input[type="number"]:hover,
    select:hover,
    input[type="color"]:hover {
      background: #4a545c;
    }

    button {
      background: var(--accent-color);
      border: none;
      border-radius: 7px;
      padding: 10px 16px;
      color: white;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: transform 0.1s, background 0.2s;
      box-shadow: var(--shadow);
    }

    button:hover {
      background: #082f51;
      transform: scale(1.04);
    }

    button:active {
      transform: scale(0.95);
    }

    .actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
      padding: 12px;
      background: var(--card-bg);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
    }

    .layers {
      padding: 12px;
      background: var(--card-bg);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
    }

    .layer-item {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      padding: 8px;
      border-bottom: 1px solid #555;
    }

    #progress,
    #metrics,
    #recommendations {
      font-size: 14px;
      padding: 12px;
      background: var(--card-bg);
      border-radius: var(--border-radius);
      text-align: center;
      box-shadow: var(--shadow);
    }

    #progress {
      display: none;
      background-color: #D12525;
    }

    #metrics,
    #recommendations {
      display: block;
      font-size: 13px;
      opacity: 0.9;
    }

    #recommendations {
      text-align: left;
    }

    .tooltip {
      visibility: hidden;
      background: #000;
      color: white;
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 6px;
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      white-space: nowrap;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .control-group:hover .tooltip {
      visibility: visible;
      opacity: 1;
    }

    @media (max-width: 600px) {

      .controls,
      .layer-item {
        grid-template-columns: 1fr;
      }

      canvas {
        max-height: calc(100vh - 400px);
      }
    }

    /* –°—Ç–∏–ª–∏ –¥–ª—è –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
    }

    .modal-content {
      background-color: #2e2e2e;
      margin: 5% auto;
      padding: 15px;
      border-radius: 12px;
      width: 80%;
      max-width: 1900px;
      color: white;
      font-family: sans-serif;
      box-shadow: 0 0 15px black;
      animation: fadeIn 0.3s ease-out;
    }

    .close {
      float: right;
      font-size: 28px;
      cursor: pointer;
    }

    .save-section,
    .load-section {}

    .preset-list {
      display: flex;
      flex-wrap: wrap;
      gap: 2px;
    }

    .preset-card {
      background: #444;
      border-radius: 8px;
      padding: 10px;
      width: 150px;
      text-align: center;
      box-shadow: 0 0 5px black;
    }

    .preset-card button {
      margin-top: 5px;
      width: 100%;
      padding: 4px;
      border: none;
      cursor: pointer;
    }

    .preset-card button.load {
      background-color: #2ecc71;
      color: white;
    }

    .preset-card button.delete {
      background-color: #e74c3c;
      color: white;

    }

    #presetNameInput {
      padding: 10px;
      border-radius: 5px;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  </style>
</head>

<body>
  <!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ -->
  <div id="presetModal" class="modal">
    <div class="modal-content">
      <span id="closeModal" class="close">&times;</span>
      <h2>üéõ –ú–µ–Ω—é –ø—Ä–µ—Å–µ—Ç–æ–≤</h2>

      <div class="save-section">
        <h3>üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–æ–≤—ã–π –ø—Ä–µ—Å–µ—Ç</h3>
        <input type="text" id="presetNameInput" placeholder="–ò–º—è –ø—Ä–µ—Å–µ—Ç–∞" />
        <button id="savePresetButton">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
      </div>

      <div class="load-section">
        <h3>üìö –ó–∞–≥—Ä—É–∑–∏—Ç—å/–£–¥–∞–ª–∏—Ç—å –ø—Ä–µ—Å–µ—Ç</h3>
        <div id="presetList" class="preset-list"></div>
      </div>
    </div>
  </div>

  <div class="container">

    <button id="openPresetModalButton">–ú–µ–Ω—é –ø—Ä–µ—Å–µ—Ç–æ–≤</button>
    <div id="metrics">SSIM: -, PSNR: -, RMSE: -, MAE: -, Entropy: -</div>

    <div class="layers">
      <button onclick="addLayer()">–î–æ–±–∞–≤–∏—Ç—å —Å–ª–æ–π</button>
      <div id="layerList"></div>
    </div>

    <div id="progress">–û–±—Ä–∞–±–æ—Ç–∫–∞: 0%</div>

    <div class="canvas-container">
      <canvas id="noiseCanvas"></canvas>
    </div>

    <div id="recommendations">–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏: -</div>

    <div class="actions">
      <button onclick="generateNoise()">üé≤ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å</button>
      <button onclick="download()">üíæ –°–∫–∞—á–∞—Ç—å</button>
      <button onclick="saveCopies()">üìÅ –°–∫–∞—á–∞—Ç—å <span id="copiesDisplay">5</span> –∫–æ–ø–∏–π:</button>
      <input type="number" id="copies" value="5" min="1" style="width: 60px;" />
      <button onclick="undo()">‚Ü©Ô∏è –û—Ç–º–µ–Ω–∏—Ç—å</button>
      <button onclick="redo()">‚Ü™Ô∏è –í–µ—Ä–Ω—É—Ç—å</button>
    </div>

    <div class="controls">
      <div class="control-group">
        <label>–®–∏—Ä–∏–Ω–∞</label>
        <input type="number" id="width" value="512" min="1" />
        <span class="tooltip">–®–∏—Ä–∏–Ω–∞ —à—É–º–∞ –≤ –ø–∏–∫—Å–µ–ª—è—Ö</span>
      </div>
      <div class="control-group">
        <label>–í—ã—Å–æ—Ç–∞</label>
        <input type="number" id="height" value="1024" min="1" />
        <span class="tooltip">–í—ã—Å–æ—Ç–∞ —à—É–º–∞ –≤ –ø–∏–∫—Å–µ–ª—è—Ö</span>
      </div>
      <div class="control-group">
        <label>–¶–≤–µ—Ç —à—É–º–∞</label>
        <input type="color" id="colorPalette" value="#ffffff" />
        <span class="tooltip">–û—Å–Ω–æ–≤–Ω–æ–π —Ü–≤–µ—Ç –¥–ª—è —Ü–≤–µ—Ç–Ω–æ–≥–æ —à—É–º–∞</span>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('noiseCanvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const progress = document.getElementById('progress');
    const metricsDiv = document.getElementById('metrics');
    const recommendationsDiv = document.getElementById('recommendations');
    const copiesInput = document.getElementById('copies');
    const copiesDisplay = document.getElementById('copiesDisplay');
    let history = [];
    let historyIndex = -1;
    let layers = [{
      id: Date.now(),
      noiseType: 'random',
      weight: 0.5,
      noiseLevel: 0.7,
      noiseScale: 10,
      smoothType: 'gaussian',
      smoothValue: 0,
      spots: 10,
      colorNoise: false,
      alphaLevel: 1
    }];

    // Web Worker
    const noiseWorker = new Worker(URL.createObjectURL(new Blob([`
      function gaussianBlur(imgData, width, height, radius) {
        if (radius <= 0) return imgData;
        const kernelSize = Math.ceil(radius) * 2 + 1;
        const kernel = [];
        let sum = 0;
        const sigma = radius / 3;

        for (let i = -Math.floor(kernelSize / 2); i <= Math.floor(kernelSize / 2); i++) {
          const value = Math.exp(-(i * i) / (2 * sigma * sigma));
          kernel.push(value);
          sum += value;
        }
        for (let i = 0; i < kernel.length; i++) kernel[i] /= sum;

        const tempData = new Uint8ClampedArray(imgData.data);
        const outputData = new Uint8ClampedArray(imgData.data);

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let r = 0, g = 0, b = 0, a = 0;
            for (let i = 0; i < kernel.length; i++) {
              const offsetX = x + i - Math.floor(kernelSize / 2);
              if (offsetX >= 0 && offsetX < width) {
                const index = (y * width + offsetX) * 4;
                const weight = kernel[i];
                r += tempData[index] * weight;
                g += tempData[index + 1] * weight;
                b += tempData[index + 2] * weight;
                a += tempData[index + 3] * weight;
              }
            }
            const index = (y * width + x) * 4;
            outputData[index] = r;
            outputData[index + 1] = g;
            outputData[index + 2] = b;
            outputData[index + 3] = a;
          }
        }

        for (let x = 0; x < width; x++) {
          for (let y = 0; y < height; y++) {
            let r = 0, g = 0, b = 0, a = 0;
            for (let i = 0; i < kernel.length; i++) {
              const offsetY = y + i - Math.floor(kernelSize / 2);
              if (offsetY >= 0 && offsetY < height) {
                const index = (offsetY * width + x) * 4;
                const weight = kernel[i];
                r += outputData[index] * weight;
                g += outputData[index + 1] * weight;
                b += outputData[index + 2] * weight;
                a += outputData[index + 3] * weight;
              }
            }
            const index = (y * width + x) * 4;
            imgData.data[index] = r;
            imgData.data[index + 1] = g;
            imgData.data[index + 2] = b;
            imgData.data[index + 3] = a;
          }
        }
        return imgData;
      }

      function medianFilter(imgData, width, height, radius) {
        if (radius <= 0) return imgData;
        const kernelSize = radius * 2 + 1;
        const outputData = new Uint8ClampedArray(imgData.data);

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const rValues = [], gValues = [], bValues = [], aValues = [];
            for (let ky = -radius; ky <= radius; ky++) {
              for (let kx = -radius; kx <= radius; kx++) {
                const nx = x + kx;
                const ny = y + ky;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                  const index = (ny * width + nx) * 4;
                  rValues.push(imgData.data[index]);
                  gValues.push(imgData.data[index + 1]);
                  bValues.push(imgData.data[index + 2]);
                  aValues.push(imgData.data[index + 3]);
                }
              }
            }
            rValues.sort((a, b) => a - b);
            gValues.sort((a, b) => a - b);
            bValues.sort((a, b) => a - b);
            aValues.sort((a, b) => a - b);
            const index = (y * width + x) * 4;
            outputData[index] = rValues[Math.floor(rValues.length / 2)];
            outputData[index + 1] = gValues[Math.floor(gValues.length / 2)];
            outputData[index + 2] = bValues[Math.floor(bValues.length / 2)];
            outputData[index + 3] = aValues[Math.floor(aValues.length / 2)];
          }
        }
        imgData.data.set(outputData);
        return imgData;
      }

      function bilateralFilter(imgData, width, height, sigma) {
        if (sigma <= 0) return imgData;
        const kernelSize = Math.ceil(sigma * 3) * 2 + 1;
        const outputData = new Uint8ClampedArray(imgData.data);
        const spatialKernel = [];
        let spatialSum = 0;

        for (let i = -Math.floor(kernelSize / 2); i <= Math.floor(kernelSize / 2); i++) {
          const value = Math.exp(-(i * i) / (2 * sigma * sigma));
          spatialKernel.push(value);
          spatialSum += value;
        }
        for (let i = 0; i < spatialKernel.length; i++) spatialKernel[i] /= spatialSum;

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let rSum = 0, gSum = 0, bSum = 0, aSum = 0, weightSum = 0;
            const centerIndex = (y * width + x) * 4;
            const centerR = imgData.data[centerIndex];
            const centerG = imgData.data[centerIndex + 1];
            const centerB = imgData.data[centerIndex + 2];
            const centerA = imgData.data[centerIndex + 3];

            for (let ky = -Math.floor(kernelSize / 2); ky <= Math.floor(kernelSize / 2); ky++) {
              for (let kx = -Math.floor(kernelSize / 2); kx <= Math.floor(kernelSize / 2); kx++) {
                const nx = x + kx;
                const ny = y + ky;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                  const index = (ny * width + nx) * 4;
                  const r = imgData.data[index];
                  const g = imgData.data[index + 1];
                  const b = imgData.data[index + 2];
                  const a = imgData.data[index + 3];

                  const colorDiff = Math.sqrt(
                    (r - centerR) ** 2 +
                    (g - centerG) ** 2 +
                    (b - centerB) ** 2
                  );
                  const colorWeight = Math.exp(-(colorDiff * colorDiff) / (2 * sigma * sigma));
                  const spatialWeight = spatialKernel[kx + Math.floor(kernelSize / 2)] * spatialKernel[ky + Math.floor(kernelSize / 2)];
                  const weight = colorWeight * spatialWeight;

                  rSum += r * weight;
                  gSum += g * weight;
                  bSum += b * weight;
                  aSum += a * weight;
                  weightSum += weight;
                }
              }
            }

            const index = (y * width + x) * 4;
            outputData[index] = rSum / weightSum;
            outputData[index + 1] = gSum / weightSum;
            outputData[index + 2] = bSum / weightSum;
            outputData[index + 3] = aSum / weightSum;
          }
        }
        imgData.data.set(outputData);
        return imgData;
      }

      function anisotropicFilter(imgData, width, height, strength) {
        if (strength <= 0) return imgData;
        const outputData = new Uint8ClampedArray(imgData.data);
        const iterations = Math.floor(strength);

        for (let iter = 0; iter < iterations; iter++) {
          const tempData = new Uint8ClampedArray(outputData);
          for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
              const index = (y * width + x) * 4;
              let rGradX = 0, rGradY = 0, gGradX = 0, gGradY = 0, bGradX = 0, bGradY = 0;

              for (let c = 0; c < 3; c++) {
                const idx = index + c;
                rGradX += (tempData[idx + 4] - tempData[idx - 4]) * 0.5;
                rGradY += (tempData[idx + width * 4] - tempData[idx - width * 4]) * 0.5;
                gGradX += (tempData[idx + 4 + 1] - tempData[idx - 4 + 1]) * 0.5;
                gGradY += (tempData[idx + width * 4 + 1] - tempData[idx - width * 4 + 1]) * 0.5;
                bGradX += (tempData[idx + 4 + 2] - tempData[idx - 4 + 2]) * 0.5;
                bGradY += (tempData[idx + width * 4 + 2] - tempData[idx - width * 4 + 2]) * 0.5;
              }

              const gradMag = Math.sqrt(rGradX ** 2 + rGradY ** 2 + gGradX ** 2 + gGradY ** 2 + bGradX ** 2 + bGradY ** 2) || 1;
              const diffusion = Math.exp(-gradMag / strength);

              for (let c = 0; c < 4; c++) {
                const idx = index + c;
                const laplacian = (
                  tempData[idx - 4] +
                  tempData[idx + 4] +
                  tempData[idx - width * 4] +
                  tempData[idx + width * 4] -
                  4 * tempData[idx]
                ) * diffusion;
                outputData[idx] = tempData[idx] + 0.25 * laplacian;
              }
            }
          }
        }
        imgData.data.set(outputData);
        return imgData;
      }

      function nonlocalMeansFilter(imgData, width, height, strength) {
        if (strength <= 0) return imgData;
        const outputData = new Uint8ClampedArray(imgData.data);
        const patchSize = 3;
        const searchWindow = 7;
        const h = strength * 10;

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let rSum = 0, gSum = 0, bSum = 0, aSum = 0, weightSum = 0;
            const centerIndex = (y * width + x) * 4;

            for (let ky = -searchWindow; ky <= searchWindow; ky++) {
              for (let kx = -searchWindow; kx <= searchWindow; kx++) {
                const nx = x + kx;
                const ny = y + ky;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                  let patchDiff = 0;
                  for (let py = -patchSize; py <= patchSize; py++) {
                    for (let px = -patchSize; px <= patchSize; px++) {
                      const cx = x + px;
                      const cy = y + py;
                      const nx2 = nx + px;
                      const ny2 = ny + py;
                      if (cx >= 0 && cx < width && cy >= 0 && cy < height && nx2 >= 0 && nx2 < width && ny2 >= 0 && ny2 < height) {
                        const idx1 = (cy * width + cx) * 4;
                        const idx2 = (ny2 * width + nx2) * 4;
                        for (let c = 0; c < 3; c++) {
                          patchDiff += (imgData.data[idx1 + c] - imgData.data[idx2 + c]) ** 2;
                        }
                      }
                    }
                  }
                  const weight = Math.exp(-patchDiff / (h * h));
                  const idx = (ny * width + nx) * 4;
                  rSum += imgData.data[idx] * weight;
                  gSum += imgData.data[idx + 1] * weight;
                  bSum += imgData.data[idx + 2] * weight;
                  aSum += imgData.data[idx + 3] * weight;
                  weightSum += weight;
                }
              }
            }

            const index = (y * width + x) * 4;
            outputData[index] = rSum / weightSum;
            outputData[index + 1] = gSum / weightSum;
            outputData[index + 2] = bSum / weightSum;
            outputData[index + 3] = aSum / weightSum;
          }
        }
        imgData.data.set(outputData);
        return imgData;
      }

      function meanFilter(imgData, width, height, radius) {
        if (radius <= 0) return imgData;
        const kernelSize = radius * 2 + 1;
        const outputData = new Uint8ClampedArray(imgData.data);

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let rSum = 0, gSum = 0, bSum = 0, aSum = 0, count = 0;
            for (let ky = -radius; ky <= radius; ky++) {
              for (let kx = -radius; kx <= radius; kx++) {
                const nx = x + kx;
                const ny = y + ky;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                  const index = (ny * width + nx) * 4;
                  rSum += imgData.data[index];
                  gSum += imgData.data[index + 1];
                  bSum += imgData.data[index + 2];
                  aSum += imgData.data[index + 3];
                  count++;
                }
              }
            }
            const index = (y * width + x) * 4;
            outputData[index] = rSum / count;
            outputData[index + 1] = gSum / count;
            outputData[index + 2] = bSum / count;
            outputData[index + 3] = aSum / count;
          }
        }
        imgData.data.set(outputData);
        return imgData;
      }

      function simplexNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        const perm = new Uint8Array(512);
        for (let i = 0; i < 512; i++) perm[i] = Math.floor(Math.random() * 256);

        function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        function lerp(t, a, b) { return a + t * (b - a); }
        function grad(hash, x, y) {
          const h = hash & 15;
          const u = h < 8 ? x : y;
          const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
          return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              const xi = Math.floor(x / scale);
              const yi = Math.floor(y / scale);
              const xf = (x / scale) - xi;
              const yf = (y / scale) - yi;
              const u = fade(xf);
              const v = fade(yf);

              const aa = perm[(perm[xi + c] + yi) & 255];
              const ab = perm[(perm[xi + c] + yi + 1) & 255];
              const ba = perm[(perm[xi + 1 + c] + yi) & 255];
              const bb = perm[(perm[xi + 1 + c] + yi + 1) & 255];

              const x1 = lerp(u, grad(aa, xf, yf), grad(ba, xf - 1, yf));
              const x2 = lerp(u, grad(ab, xf, yf - 1), grad(bb, xf - 1, yf - 1));
              const value = lerp(v, x1, x2);

              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, ((value + 1) / 2) * intensity * 255));
            }
          }
        }
        return noise;
      }

      function perlinNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              let value = 0;
              let amplitude = 1;
              let frequency = 1 / scale;
              for (let i = 0; i < 8; i++) {
                const sampleX = x * frequency;
                const sampleY = y * frequency;
                value += amplitude * (Math.random() - 0.5) * 2;
                amplitude *= 0.5;
                frequency *= 2;
              }
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, (value * intensity * 255 + 255) / 2));
            }
          }
        }
        return noise;
      }

      function fractalNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              let value = 0;
              let amplitude = 1;
              let frequency = 1 / scale;
              for (let i = 0; i < 6; i++) {
                const sampleX = x * frequency;
                const sampleY = y * frequency;
                value += amplitude * (Math.sin(sampleX) + Math.cos(sampleY));
                amplitude *= 0.5;
                frequency *= 2;
              }
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, (value * intensity * 255 + 255) / 2));
            }
          }
        }
        return noise;
      }

      function cellularNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        const points = [];
        const numPoints = Math.floor(width * height / (scale * scale));
        for (let i = 0; i < numPoints; i++) {
          points.push([Math.random() * width, Math.random() * height]);
        }

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let minDist = Infinity;
            for (const point of points) {
              const dx = x - point[0];
              const dy = y - point[1];
              const dist = Math.sqrt(dx * dx + dy * dy);
              minDist = Math.min(minDist, dist);
            }
            const value = Math.min(1, minDist / scale) * intensity;
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, value * 255));
            }
          }
        }
        return noise;
      }

      function worleyNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        const points = [];
        const numPoints = Math.floor(width * height / (scale * scale));
        for (let i = 0; i < numPoints; i++) {
          points.push([Math.random() * width, Math.random() * height]);
        }

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let distances = [];
            for (const point of points) {
              const dx = x - point[0];
              const dy = y - point[1];
              distances.push(Math.sqrt(dx * dx + dy * dy));
            }
            distances.sort((a, b) => a - b);
            const value = distances[1] / scale * intensity;
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, value * 255));
            }
          }
        }
        return noise;
      }

      function voronoiNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        const points = [];
        const numPoints = Math.floor(width * height / (scale * scale));
        for (let i = 0; i < numPoints; i++) {
          points.push([Math.random() * width, Math.random() * height]);
        }

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let minDist = Infinity;
            let secondMinDist = Infinity;
            for (const point of points) {
              const dx = x - point[0];
              const dy = y - point[1];
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < minDist) {
                secondMinDist = minDist;
                minDist = dist;
              } else if (dist < secondMinDist) {
                secondMinDist = dist;
              }
            }
            const value = (secondMinDist - minDist) / scale * intensity;
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, value * 255));
            }
          }
        }
        return noise;
      }

      function billowNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              let value = 0;
              let amplitude = 1;
              let frequency = 1 / scale;
              for (let i = 0; i < 6; i++) {
                const sampleX = x * frequency;
                const sampleY = y * frequency;
                value += amplitude * Math.abs(Math.sin(sampleX) + Math.cos(sampleY));
                amplitude *= 0.5;
                frequency *= 2;
              }
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, (value * intensity * 255 + 255) / 2));
            }
          }
        }
        return noise;
      }

      function ridgedNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              let value = 0;
              let amplitude = 1;
              let frequency = 1 / scale;
              for (let i = 0; i < 6; i++) {
                const sampleX = x * frequency;
                const sampleY = y * frequency;
                let n = Math.sin(sampleX) + Math.cos(sampleY);
                n = 1 - Math.abs(n);
                n *= n;
                value += amplitude * n;
                amplitude *= 0.5;
                frequency *= 2;
              }
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, (value * intensity * 255 + 255) / 2));
            }
          }
        }
        return noise;
      }

      function whiteNoise(width, height, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.random() * 255 * intensity;
            }
          }
        }
        return noise;
      }

      function pinkNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              let value = 0;
              let amplitude = 1;
              let frequency = 1 / scale;
              for (let i = 0; i < 6; i++) {
                value += amplitude * (Math.random() - 0.5) * 2 / frequency;
                amplitude *= 0.5;
                frequency *= 2;
              }
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, (value * intensity * 255 + 255) / 2));
            }
          }
        }
        return noise;
      }

      function brownNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        let lastValue = [0, 0, 0];
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              lastValue[c] += (Math.random() - 0.5) * 2 / scale;
              lastValue[c] = Math.min(1, Math.max(-1, lastValue[c]));
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, ((lastValue[c] + 1) / 2) * intensity * 255));
            }
          }
        }
        return noise;
      }

      function blueNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              let value = 0;
              let amplitude = 1;
              let frequency = 1 / scale;
              for (let i = 0; i < 6; i++) {
                value += amplitude * (Math.random() - 0.5) * 2 * frequency;
                amplitude *= 0.5;
                frequency *= 2;
              }
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, (value * intensity * 255 + 255) / 2));
            }
          }
        }
        return noise;
      }

      function gradientNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              const nx = x / scale;
              const ny = y / scale;
              const value = (Math.sin(nx) + Math.cos(ny)) * intensity;
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, (value * 255 + 255) / 2));
            }
          }
        }
        return noise;
      }

      function sparkleNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        const points = [];
        const numPoints = Math.floor(width * height / (scale * scale));
        for (let i = 0; i < numPoints; i++) {
          points.push([Math.random() * width, Math.random() * height]);
        }

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let value = 0;
            for (const point of points) {
              const dx = x - point[0];
              const dy = y - point[1];
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < scale) {
                value += (1 - dist / scale) * intensity;
              }
            }
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, value * 255));
            }
          }
        }
        return noise;
      }

      function impulseNoise(width, height, intensity, colorNoise) {
  const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
        const rand = Math.random();
        noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = rand < intensity * 0.1 ? (rand < 0.05 ? 255 : 0) : 128;
      }
    }
  }
  return noise;
}

function stripeNoise(width, height, scale, intensity, colorNoise) {
  const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
  const stripeWidth = scale * 10;
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const value = Math.sin(x / stripeWidth) * intensity;
      for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
        noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, (value * 255 + 255) / 2));
      }
    }
  }
  return noise;
}

function turbulentNoise(width, height, scale, intensity, colorNoise) {
  const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let value = 0;
      let amplitude = 1;
      let frequency = 1 / scale;
      for (let i = 0; i < 6; i++) {
        const sampleX = x * frequency;
        const sampleY = y * frequency;
        value += amplitude * Math.abs(Math.sin(sampleX + Math.cos(sampleY * frequency)));
        amplitude *= 0.5;
        frequency *= 2;
      }
      for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
        noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, (value * intensity * 255 + 255) / 2));
      }
    }
  }
  return noise;
}

function multilayerPerlinNoise(width, height, scale, intensity, colorNoise) {
  const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
  const octaves = 4; // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–∫—Ç–∞–≤ –¥–ª—è –º–Ω–æ–≥–æ—Å–ª–æ–π–Ω–æ—Å—Ç–∏
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
        let value = 0;
        let amplitude = 1;
        let frequency = 1 / scale;
        for (let i = 0; i < octaves; i++) {
          const sampleX = x * frequency + c * 100; // –°–º–µ—â–µ–Ω–∏–µ –¥–ª—è —Ü–≤–µ—Ç–Ω–æ–≥–æ —à—É–º–∞
          const sampleY = y * frequency + c * 100;
          value += amplitude * (Math.sin(sampleX) + Math.cos(sampleY));
          amplitude *= 0.5; // –£–º–µ–Ω—å—à–µ–Ω–∏–µ –∞–º–ø–ª–∏—Ç—É–¥—ã –¥–ª—è –∫–∞–∂–¥–æ–π –æ–∫—Ç–∞–≤—ã
          frequency *= 2; // –£–≤–µ–ª–∏—á–µ–Ω–∏–µ —á–∞—Å—Ç–æ—Ç—ã
        }
        noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, ((value + 2) / 4) * intensity * 255));
      }
    }
  }
  return noise;
}

function diamondSquareNoise(width, height, scale, intensity, colorNoise) {
  const size = Math.max(width, height);
  const gridSize = Math.pow(2, Math.ceil(Math.log2(size))) + 1;
  const grid = new Array(gridSize).fill().map(() => new Array(gridSize).fill(0));
  
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —É–≥–ª–æ–≤
  grid[0][0] = (Math.random() - 0.5) * intensity * 255;
  grid[0][gridSize - 1] = (Math.random() - 0.5) * intensity * 255;
  grid[gridSize - 1][0] = (Math.random() - 0.5) * intensity * 255;
  grid[gridSize - 1][gridSize - 1] = (Math.random() - 0.5) * intensity * 255;

  let step = gridSize - 1;
  let roughness = intensity;
  
  while (step > 1) {
    const halfStep = step / 2;
    
    // Diamond step
    for (let y = halfStep; y < gridSize; y += step) {
      for (let x = halfStep; x < gridSize; x += step) {
        const avg = (
          grid[y - halfStep][x - halfStep] +
          grid[y - halfStep][x + halfStep] +
          grid[y + halfStep][x - halfStep] +
          grid[y + halfStep][x + halfStep]
        ) / 4;
        grid[y][x] = avg + (Math.random() - 0.5) * roughness * 255;
      }
    }
    
    // Square step
    for (let y = 0; y < gridSize; y += halfStep) {
      for (let x = (y % step === 0) ? halfStep : 0; x < gridSize; x += step) {
        let sum = 0, count = 0;
        if (x >= halfStep) { sum += grid[y][x - halfStep]; count++; }
        if (x + halfStep < gridSize) { sum += grid[y][x + halfStep]; count++; }
        if (y >= halfStep) { sum += grid[y - halfStep][x]; count++; }
        if (y + halfStep < gridSize) { sum += grid[y + halfStep][x]; count++; }
        grid[y][x] = sum / count + (Math.random() - 0.5) * roughness * 255;
      }
    }
    
    step /= 2;
    roughness *= 0.5; // –£–º–µ–Ω—å—à–µ–Ω–∏–µ —à–µ—Ä–æ—Ö–æ–≤–∞—Ç–æ—Å—Ç–∏
  }

  const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
        const gridX = Math.floor((x / width) * gridSize);
        const gridY = Math.floor((y / height) * gridSize);
        noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, (grid[gridY][gridX] + 255) / 2));
      }
    }
  }
  return noise;
}

function ridgedMultifractalNoise(width, height, scale, intensity, colorNoise) {
  const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
  const octaves = 4;
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
        let value = 0;
        let amplitude = 1;
        let frequency = 1 / scale;
        let prev = 1;
        for (let i = 0; i < octaves; i++) {
          const sampleX = x * frequency + c * 100;
          const sampleY = y * frequency + c * 100;
          let n = Math.sin(sampleX) + Math.cos(sampleY);
          n = Math.abs(n);
          n = 1 - n; // –ò–Ω–≤–µ—Ä—Å–∏—è –¥–ª—è —Ä–µ–∑–∫–∏—Ö –ø–∏–∫–æ–≤
          n *= n * prev; // –£—Å–∏–ª–µ–Ω–∏–µ —Ä–µ–∑–∫–æ—Å—Ç–∏
          prev = n;
          value += amplitude * n;
          amplitude *= 0.5;
          frequency *= 2;
        }
        noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, (value * intensity * 255 + 255) / 2));
      }
    }
  }
  return noise;
}
function midpointDisplacementNoise(width, height, scale, intensity, colorNoise) {
  const size = Math.max(width, height);
  const gridSize = Math.pow(2, Math.ceil(Math.log2(size))) + 1;
  const grid = new Array(gridSize).fill().map(() => new Array(gridSize).fill(0));
  
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —É–≥–ª–æ–≤
  grid[0][0] = (Math.random() - 0.5) * intensity * 255;
  grid[0][gridSize - 1] = (Math.random() - 0.5) * intensity * 255;
  grid[gridSize - 1][0] = (Math.random() - 0.5) * intensity * 255;
  grid[gridSize - 1][gridSize - 1] = (Math.random() - 0.5) * intensity * 255;

  let step = gridSize - 1;
  let roughness = intensity;
  
  while (step > 1) {
    const halfStep = step / 2;
    
    // Midpoint displacement
    for (let y = halfStep; y < gridSize; y += step) {
      for (let x = halfStep; x < gridSize; x += step) {
        const avg = (
          grid[y - halfStep][x - halfStep] +
          grid[y - halfStep][x + halfStep] +
          grid[y + halfStep][x - halfStep] +
          grid[y + halfStep][x + halfStep]
        ) / 4;
        grid[y][x] = avg + (Math.random() - 0.5) * roughness * 255;
      }
    }
    
    step /= 2;
    roughness *= 0.6; // –£–º–µ–Ω—å—à–µ–Ω–∏–µ —à–µ—Ä–æ—Ö–æ–≤–∞—Ç–æ—Å—Ç–∏
  }

  const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
        const gridX = Math.floor((x / width) * gridSize);
        const gridY = Math.floor((y / height) * gridSize);
        noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, (grid[gridY][gridX] + 255) / 2));
      }
    }
  }
  return noise;
}

function voronoiRidgedNoise(width, height, scale, intensity, colorNoise) {
  const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
  const points = [];
  const numPoints = Math.floor(width * height / (scale * scale));
  for (let i = 0; i < numPoints; i++) {
    points.push([Math.random() * width, Math.random() * height]);
  }

  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let minDist = Infinity;
      let secondMinDist = Infinity;
      for (const point of points) {
        const dx = x - point[0];
        const dy = y - point[1];
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < minDist) {
          secondMinDist = minDist;
          minDist = dist;
        } else if (dist < secondMinDist) {
          secondMinDist = dist;
        }
      }
      const value = Math.abs(secondMinDist - minDist) / scale * intensity;
      for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
        noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, (1 - value) * 255)); // –ò–Ω–≤–µ—Ä—Å–∏—è –¥–ª—è —Ä–µ–∑–∫–æ—Å—Ç–∏
      }
    }
  }
  return noise;
}

function waveletNoise(width, height, scale, intensity, colorNoise) {
  const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
  const layers = 3; // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª–æ–µ–≤ –≤–µ–π–≤–ª–µ—Ç–æ–≤
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
        let value = 0;
        let amplitude = 1;
        let frequency = 1 / scale;
        for (let i = 0; i < layers; i++) {
          const sampleX = x * frequency + c * 50;
          const sampleY = y * frequency + c * 50;
          value += amplitude * (Math.sin(sampleX) * Math.cos(sampleY) + (Math.random() - 0.5));
          amplitude *= 0.7;
          frequency *= 1.5;
        }
        noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, ((value + 1) / 2) * intensity * 255));
      }
    }
  }
  return noise;
}
  function erosionNoise(width, height, scale, intensity, colorNoise) {
  const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
  const baseNoise = perlinNoise(width, height, scale * 2, intensity, colorNoise); // –ë–∞–∑–æ–≤—ã–π –ü–µ—Ä–ª–∏–Ω –¥–ª—è –≤—ã—Å–æ—Ç
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
        const index = (y * width + x) * (colorNoise ? 3 : 1) + c;
        let value = baseNoise[index] / 255;
        // –ò–º–∏—Ç–∞—Ü–∏—è —ç—Ä–æ–∑–∏–∏: —É—Å–∏–ª–µ–Ω–∏–µ –Ω–∏–∑–∏–Ω –∏ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ –ø–∏–∫–æ–≤
        value = Math.pow(value, 1.5) * (1 - Math.abs(Math.sin(x / scale) * Math.cos(y / scale)) * 0.3);
        noise[index] = Math.min(255, Math.max(0, value * intensity * 255));
      }
    }
  }
  return noise;
}

function flowNoise(width, height, scale, intensity, colorNoise) {
  const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
        // –ò–º–∏—Ç–∞—Ü–∏—è –ø–æ—Ç–æ–∫–æ–≤ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Å–∏–Ω—É—Å–æ–∏–¥–∞–ª—å–Ω—ã—Ö –∏—Å–∫–∞–∂–µ–Ω–∏–π
        const sampleX = x / scale + Math.sin(y / scale) * 2;
        const sampleY = y / scale + Math.cos(x / scale) * 2;
        let value = (Math.sin(sampleX) + Math.cos(sampleY)) * 0.5;
        value += (Math.random() - 0.5) * 0.2; // –õ–µ–≥–∫–∞—è —Å–ª—É—á–∞–π–Ω–æ—Å—Ç—å
        noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, ((value + 1) / 2) * intensity * 255));
      }
    }
  }
  return noise;
}

function organicNoise(width, height, scale, intensity, colorNoise) {
  const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
  const points = [];
  const numPoints = Math.floor(width * height / (scale * scale));
  for (let i = 0; i < numPoints; i++) {
    points.push([Math.random() * width, Math.random() * height]);
  }

  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let value = 0;
      for (const point of points) {
        const dx = x - point[0];
        const dy = y - point[1];
        const dist = Math.sqrt(dx * dx + dy * dy);
        value += Math.exp(-dist / scale) * intensity; // –û—Ä–≥–∞–Ω–∏—á–µ—Å–∫–∏–π —Å–ø–∞–¥
      }
      for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
        noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, value * 255));
      }
    }
  }
  return noise;
}
  function cloudNoise(width, height, scale, intensity, colorNoise) {
  const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
  const baseNoise = perlinNoise(width, height, scale * 3, intensity, colorNoise); // –ë–∞–∑–æ–≤—ã–π –ü–µ—Ä–ª–∏–Ω –¥–ª—è –º—è–≥–∫–∏—Ö –æ–±–ª–∞–∫–æ–≤
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
        const index = (y * width + x) * (colorNoise ? 3 : 1) + c;
        let value = baseNoise[index] / 255;
        // –ò–º–∏—Ç–∞—Ü–∏—è –æ–±–ª–∞–∫–æ–≤: —É—Å–∏–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç—Ä–∞—Å—Ç–∞ –∏ –º—è–≥–∫–∏–µ –∫—Ä–∞—è
        value = Math.pow(value, 2) * (1 + Math.sin(x / scale + y / scale) * 0.2);
        noise[index] = Math.min(255, Math.max(0, value * intensity * 255));
      }
    }
  }
  return noise;
}

function lavaNoise(width, height, scale, intensity, colorNoise) {
  const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
        // –ò–º–∏—Ç–∞—Ü–∏—è –ª–∞–≤—ã: —Ç—É—Ä–±—É–ª–µ–Ω—Ç–Ω—ã–µ –∏—Å–∫–∞–∂–µ–Ω–∏—è —Å —è—Ä–∫–∏–º–∏ –ø—è—Ç–Ω–∞–º–∏
        const sampleX = x / scale + Math.sin(y / (scale * 0.5)) * 1.5;
        const sampleY = y / scale + Math.cos(x / (scale * 0.5)) * 1.5;
        let value = Math.abs(Math.sin(sampleX) * Math.cos(sampleY));
        value += (Math.random() - 0.5) * 0.3; // –°–ª—É—á–∞–π–Ω—ã–µ –≤—Å–ø—ã—à–∫–∏
        noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, value * intensity * 255));
      }
    }
  }
  return noise;
}

function fabricNoise(width, height, scale, intensity, colorNoise) {
  const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
        // –ò–º–∏—Ç–∞—Ü–∏—è —Ç–∫–∞–Ω–∏: –≤–æ–ª–æ–∫–Ω–∏—Å—Ç—ã–µ —É–∑–æ—Ä—ã —Å –ø–µ—Ä–µ–ø–ª–µ—Ç–µ–Ω–∏—è–º–∏
        const sampleX = x / scale;
        const sampleY = y / scale;
        let value = (Math.sin(sampleX * 2) + Math.cos(sampleY * 2)) * 0.5;
        value += Math.sin((x + y) / scale) * 0.3; // –î–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–µ –≤–æ–ª–æ–∫–Ω–∞
        value += (Math.random() - 0.5) * 0.1; // –õ–µ–≥–∫–∞—è —Å–ª—É—á–∞–π–Ω–æ—Å—Ç—å
        noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, ((value + 1) / 2) * intensity * 255));
      }
    }
  }
  return noise;
}function cloudNoise(width, height, scale, intensity, colorNoise) {
  const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
  const baseNoise = perlinNoise(width, height, scale * 3, intensity, colorNoise); // –ë–∞–∑–æ–≤—ã–π –ü–µ—Ä–ª–∏–Ω –¥–ª—è –º—è–≥–∫–∏—Ö –æ–±–ª–∞–∫–æ–≤
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
        const index = (y * width + x) * (colorNoise ? 3 : 1) + c;
        let value = baseNoise[index] / 255;
        // –ò–º–∏—Ç–∞—Ü–∏—è –æ–±–ª–∞–∫–æ–≤: —É—Å–∏–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç—Ä–∞—Å—Ç–∞ –∏ –º—è–≥–∫–∏–µ –∫—Ä–∞—è
        value = Math.pow(value, 2) * (1 + Math.sin(x / scale + y / scale) * 0.2);
        noise[index] = Math.min(255, Math.max(0, value * intensity * 255));
      }
    }
  }
  return noise;
}

function lavaNoise(width, height, scale, intensity, colorNoise) {
  const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
        // –ò–º–∏—Ç–∞—Ü–∏—è –ª–∞–≤—ã: —Ç—É—Ä–±—É–ª–µ–Ω—Ç–Ω—ã–µ –∏—Å–∫–∞–∂–µ–Ω–∏—è —Å —è—Ä–∫–∏–º–∏ –ø—è—Ç–Ω–∞–º–∏
        const sampleX = x / scale + Math.sin(y / (scale * 0.5)) * 1.5;
        const sampleY = y / scale + Math.cos(x / (scale * 0.5)) * 1.5;
        let value = Math.abs(Math.sin(sampleX) * Math.cos(sampleY));
        value += (Math.random() - 0.5) * 0.3; // –°–ª—É—á–∞–π–Ω—ã–µ –≤—Å–ø—ã—à–∫–∏
        noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, value * intensity * 255));
      }
    }
  }
  return noise;
}

function fabricNoise(width, height, scale, intensity, colorNoise) {
  const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
        // –ò–º–∏—Ç–∞—Ü–∏—è —Ç–∫–∞–Ω–∏: –≤–æ–ª–æ–∫–Ω–∏—Å—Ç—ã–µ —É–∑–æ—Ä—ã —Å –ø–µ—Ä–µ–ø–ª–µ—Ç–µ–Ω–∏—è–º–∏
        const sampleX = x / scale;
        const sampleY = y / scale;
        let value = (Math.sin(sampleX * 2) + Math.cos(sampleY * 2)) * 0.5;
        value += Math.sin((x + y) / scale) * 0.3; // –î–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–µ –≤–æ–ª–æ–∫–Ω–∞
        value += (Math.random() - 0.5) * 0.1; // –õ–µ–≥–∫–∞—è —Å–ª—É—á–∞–π–Ω–æ—Å—Ç—å
        noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, ((value + 1) / 2) * intensity * 255));
      }
    }
  }
  return noise;
}
      self.onmessage = function(e) {
        try {
          const { width, height, layer, spots, colorPalette } = e.data;
          const { noiseType, noiseLevel, noiseScale, smoothType, smoothValue, colorNoise, alphaLevel } = layer;

          const imgData = new ImageData(width, height);
          const spotArray = [];
          for (let i = 0; i < spots; i++) {
            spotArray.push({
              x: Math.random() * width,
              y: Math.random() * height,
              r: Math.random() * 200 + 100
            });
          }

          let noiseValues;
          if (noiseType === 'perlin') {
            noiseValues = perlinNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'simplex') {
            noiseValues = simplexNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'fractal') {
            noiseValues = fractalNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'cellular') {
            noiseValues = cellularNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'worley') {
            noiseValues = worleyNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'erosion') {
  noiseValues = erosionNoise(width, height, noiseScale, noiseLevel, colorNoise);
} else if (noiseType === 'flow') {
  noiseValues = flowNoise(width, height, noiseScale, noiseLevel, colorNoise);
} else if (noiseType === 'organic') {
  noiseValues = organicNoise(width, height, noiseScale, noiseLevel, colorNoise);
} else if (noiseType === 'voronoi') {
            noiseValues = voronoiNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'cloud') {
  noiseValues = cloudNoise(width, height, noiseScale, noiseLevel, colorNoise);
} else if (noiseType === 'lava') {
  noiseValues = lavaNoise(width, height, noiseScale, noiseLevel, colorNoise);
} else if (noiseType === 'fabric') {
  noiseValues = fabricNoise(width, height, noiseScale, noiseLevel, colorNoise);
}

            else if (noiseType === 'billow') {
            noiseValues = billowNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'ridged') {
            noiseValues = ridgedNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'white') {
            noiseValues = whiteNoise(width, height, noiseLevel, colorNoise);
          } else if (noiseType === 'pink') {
            noiseValues = pinkNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'brown') {
            noiseValues = brownNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'midpointDisplacement') {
  noiseValues = midpointDisplacementNoise(width, height, noiseScale, noiseLevel, colorNoise);
} else if (noiseType === 'voronoiRidged') {
  noiseValues = voronoiRidgedNoise(width, height, noiseScale, noiseLevel, colorNoise);
} else if (noiseType === 'wavelet') {
  noiseValues = waveletNoise(width, height, noiseScale, noiseLevel, colorNoise);

            } else if (noiseType === 'blue') {
            noiseValues = blueNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'multilayerPerlin') {
  noiseValues = multilayerPerlinNoise(width, height, noiseScale, noiseLevel, colorNoise);
} else if (noiseType === 'diamondSquare') {
  noiseValues = diamondSquareNoise(width, height, noiseScale, noiseLevel, colorNoise);
} else if (noiseType === 'ridgedMultifractal') {
  noiseValues = ridgedMultifractalNoise(width, height, noiseScale, noiseLevel, colorNoise);

            } else if (noiseType === 'saltPepper') {
            noiseValues = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
                  const rand = Math.random();
                  noiseValues[(y * width + x) * (colorNoise ? 3 : 1) + c] = rand < 0.05 * noiseLevel ? 255 : rand > 1 - 0.05 * noiseLevel ? 0 : 128;
                }
              }
            }
          } else if (noiseType === 'gaussian') {
            noiseValues = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
                  const mean = 128;
                  const std = 50 * noiseLevel;
                  const value = mean + std * Math.sqrt(-2 * Math.log(Math.random())) * Math.cos(2 * Math.PI * Math.random());
                  noiseValues[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, value));
                }
              }
            }
          } else if (noiseType === 'gradient') {
            noiseValues = gradientNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'sparkle') {
            noiseValues = sparkleNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else {
            noiseValues = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
                  noiseValues[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.random() * 255 * noiseLevel;
                }
              }
            }
          }

          const paletteRGB = colorPalette ? [
            parseInt(colorPalette.slice(1, 3), 16),
            parseInt(colorPalette.slice(3, 5), 16),
            parseInt(colorPalette.slice(5, 7), 16)
          ] : [255, 255, 255];

          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const index = (y * width + x) * 4;
              let alphaMask = 1;

              for (let spot of spotArray) {
                const dx = x - spot.x;
                const dy = y - spot.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const influence = Math.max(0, 1 - dist / spot.r);
                alphaMask *= (1 - 0.8 * influence);
              }

              const nIndex = (y * width + x) * (colorNoise ? 3 : 1);
              let r = noiseValues[nIndex];
              let g = colorNoise ? noiseValues[nIndex + 1] : r;
              let b = colorNoise ? noiseValues[nIndex + 2] : r;

              r *= paletteRGB[0] / 255;
              g *= paletteRGB[1] / 255;
              b *= paletteRGB[2] / 255;

              const alpha = Math.floor(255 * alphaMask * alphaLevel);

              imgData.data[index] = r;
              imgData.data[index + 1] = g;
              imgData.data[index + 2] = b;
              imgData.data[index + 3] = alpha;
            }
          }

          let processedData = imgData;
          if (smoothType === 'gaussian' && smoothValue > 0) {
            processedData = gaussianBlur(processedData, width, height, smoothValue);
          } else if (smoothType === 'median' && smoothValue > 0) {
            processedData = medianFilter(processedData, width, height, Math.round(smoothValue));
          } else if (smoothType === 'bilateral' && smoothValue > 0) {
            processedData = bilateralFilter(processedData, width, height, smoothValue);
          } else if (smoothType === 'anisotropic' && smoothValue > 0) {
            processedData = anisotropicFilter(processedData, width, height, smoothValue);
          } else if (smoothType === 'nonlocal' && smoothValue > 0) {
            processedData = nonlocalMeansFilter(processedData, width, height, smoothValue);
          } else if (smoothType === 'mean' && smoothValue > 0) {
            processedData = meanFilter(processedData, width, height, Math.round(smoothValue));
          }

          self.postMessage({ imgData: processedData }, [processedData.data.buffer]);
        } catch (error) {
          self.postMessage({ error: error.message });
        }
      };
    `], { type: 'application/javascript' })));

    function resizeCanvas(width, height) {
      canvas.width = Math.max(1, width);
      canvas.height = Math.max(1, height);
    }

    function calculateMetrics(imgData, width, height) {
      const refData = new ImageData(width, height); // –ß–µ—Ä–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∫–∞–∫ —ç—Ç–∞–ª–æ–Ω
      let mse = 0, mae = 0, ssim = 0, entropy = 0, ae = 0, ncc = 0;
      let mean1 = 0, mean2 = 0, var1 = 0, var2 = 0, cov = 0;
      const c1 = 0.01 * 255 * 255, c2 = 0.03 * 255 * 255;
      const histogram = new Array(256).fill(0);
      let sumDiff = 0, sum1 = 0, sum2 = 0, sum1squared = 0, sum2squared = 0, sumProduct = 0;

      for (let i = 0; i < width * height * 4; i += 4) {
        const v1 = (imgData.data[i] + imgData.data[i + 1] + imgData.data[i + 2]) / 3;
        const v2 = (refData.data[i] + refData.data[i + 1] + refData.data[i + 2]) / 3;
        const diff = v1 - v2;
        mse += diff * diff;
        mae += Math.abs(diff);
        sumDiff += diff; // –î–ª—è AE
        mean1 += v1;
        mean2 += v2;
        sum1 += v1;
        sum2 += v2;
        sum1squared += v1 * v1;
        sum2squared += v2 * v2;
        sumProduct += v1 * v2;
        histogram[Math.floor(v1)]++;
      }

      const totalPixels = width * height;
      mse /= totalPixels;
      mae /= totalPixels;
      mean1 /= totalPixels;
      mean2 /= totalPixels;
      ae = sumDiff / totalPixels; // –°—Ä–µ–¥–Ω—è—è –æ—à–∏–±–∫–∞ (AE)

      // NCC = Œ£((x - Œºx)(y - Œºy)) / sqrt(Œ£(x - Œºx)¬≤ * Œ£(y - Œºy)¬≤)
      ncc = (sumProduct - sum1 * sum2 / totalPixels) /
        Math.sqrt((sum1squared - sum1 * sum1 / totalPixels) * (sum2squared - sum2 * sum2 / totalPixels)) || 0;

      for (let i = 0; i < width * height * 4; i += 4) {
        const v1 = (imgData.data[i] + imgData.data[i + 1] + imgData.data[i + 2]) / 3;
        const v2 = (refData.data[i] + refData.data[i + 1] + refData.data[i + 2]) / 3;
        var1 += (v1 - mean1) ** 2;
        var2 += (v2 - mean2) ** 2;
        cov += (v1 - mean1) * (v2 - mean2);
      }

      var1 /= totalPixels;
      var2 /= totalPixels;
      cov /= totalPixels;

      ssim = ((2 * mean1 * mean2 + c1) * (2 * cov + c2)) / ((mean1 ** 2 + mean2 ** 2 + c1) * (var1 + var2 + c2));
      const psnr = 10 * Math.log10((255 * 255) / (mse || 1));
      const rmse = Math.sqrt(mse);

      for (let i = 0; i < 256; i++) {
        if (histogram[i] > 0) {
          const p = histogram[i] / totalPixels;
          entropy -= p * Math.log2(p);
        }
      }

      return { ssim: ssim * 100, psnr, rmse, mae, entropy, ae, ncc: ncc * 100 };
    }

    function updateRecommendations(metrics, generationTime) {
      const recs = [];

      // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ SSIM (Structural Similarity Index)
      if (metrics.ssim > 70) {
        recs.push("–°—Ö–æ–∂–µ—Å—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –≤—ã—Å–æ–∫–∞ (SSIM > 70%). –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —É–≤–µ–ª–∏—á–∏—Ç—å –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —à—É–º–∞ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–∏–ø—ã —à—É–º–∞ —Å –≤—ã—Å–æ–∫–æ–π –≤–∞—Ä–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å—é (–Ω–∞–ø—Ä–∏–º–µ—Ä, 'saltPepper', 'sparkle', 'white').");
      } else if (metrics.ssim < 30) {
        recs.push("–°—Ç—Ä—É–∫—Ç—É—Ä–Ω–æ–µ –æ—Ç–ª–∏—á–∏–µ –æ—á–µ–Ω—å –≤–µ–ª–∏–∫–æ (SSIM < 30%). –®—É–º –æ—á–µ–Ω—å –∞–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–π.");
      }

      // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ PSNR (Peak Signal-to-Noise Ratio)
      if (metrics.psnr > 30) {
        recs.push("PSNR –≤—ã—Å–æ–∫–∏–π (> 30 –¥–ë) ‚Äî –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –º–∞–ª–æ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç –æ—Ä–∏–≥–∏–Ω–∞–ª–∞. –£–≤–µ–ª–∏—á—å—Ç–µ —É—Ä–æ–≤–µ–Ω—å —à—É–º–∞ –∏–ª–∏ –ø—Ä–∏–º–µ–Ω–∏—Ç–µ —Ü–≤–µ—Ç–Ω–æ–π —à—É–º.");
      } else if (metrics.psnr < 20) {
        recs.push("PSNR –Ω–∏–∑–∫–∏–π (< 20 –¥–ë) ‚Äî —à—É–º –æ—á–µ–Ω—å —Å–∏–ª—å–Ω—ã–π.");
      }

      // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ RMSE (Root Mean Square Error)
      if (metrics.rmse > 80) {
        recs.push("RMSE –æ—á–µ–Ω—å –≤—ã—Å–æ–∫–∏–π (> 80) ‚Äî —à—É–º –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –º–µ–Ω—è–µ—Ç —è—Ä–∫–æ—Å—Ç—å –ø–∏–∫—Å–µ–ª–µ–π.");
      } else if (metrics.rmse < 20) {
        recs.push("RMSE –Ω–∏–∑–∫–∏–π (< 20) ‚Äî –∏–∑–º–µ–Ω–µ–Ω–∏—è –º–µ–∂–¥—É –æ—Ä–∏–≥–∏–Ω–∞–ª–æ–º –∏ —à—É–º–æ–≤—ã–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã. –£—Å–∏–ª—å—Ç–µ —à—É–º –∏–ª–∏ –∏–∑–º–µ–Ω–∏—Ç–µ —Ç–∏–ø.");
      }

      // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ MAE (Mean Absolute Error)
      if (metrics.mae > 60) {
        recs.push("MAE –≤—ã—à–µ 60 ‚Äî —Å—Ä–µ–¥–Ω–µ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –≤–µ–ª–∏–∫–æ. –®—É–º —Å–∏–ª—å–Ω–æ –≤–ª–∏—è–µ—Ç –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.");
      } else if (metrics.mae < 10) {
        recs.push("MAE –Ω–∏–∂–µ 10 ‚Äî —Ä–∞–∑–ª–∏—á–∏—è –ø–æ—á—Ç–∏ –Ω–µ–∑–∞–º–µ—Ç–Ω—ã. –£–≤–µ–ª–∏—á—å—Ç–µ –≤–µ—Å —Å–ª–æ—è –∏–ª–∏ –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —à—É–º–∞.");
      }

      // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ AE (Average Error)
      if (Math.abs(metrics.ae) > 50) {
        recs.push("AE (—Å—Ä–µ–¥–Ω—è—è —Ä–∞–∑–Ω–∏—Ü–∞) –±–æ–ª—å—à–µ 50 ‚Äî —à—É–º —Å–º–µ—â–∞–µ—Ç —è—Ä–∫–æ—Å—Ç—å –≤ —Å—Ç–æ—Ä–æ–Ω—É —Å–≤–µ—Ç–ª—ã—Ö –∏–ª–∏ —Ç–µ–º–Ω—ã—Ö —Ç–æ–Ω–æ–≤. –≠—Ç–æ –º–æ–∂–µ—Ç –ø–æ–≤–ª–∏—è—Ç—å –Ω–∞ –≤–æ—Å–ø—Ä–∏—è—Ç–∏–µ.");
      } else if (metrics.ae === 0) {
        recs.push("AE —Ä–∞–≤–µ–Ω 0 ‚Äî —à—É–º –Ω–µ –≤–ª–∏—è–µ—Ç –Ω–∞ –æ–±—â—É—é —è—Ä–∫–æ—Å—Ç—å. –≠—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ, –µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–π —à—É–º.");
      }

      // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ NCC (Normalized Cross-Correlation)
      if (metrics.ncc > 70) {
        recs.push("NCC –≤—ã—à–µ 70% ‚Äî –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å–∏–ª—å–Ω–æ –∫–æ—Ä—Ä–µ–ª–∏—Ä—É—é—Ç. –°–Ω–∏–∑—å—Ç–µ —Å—Ö–æ–∂–µ—Å—Ç—å —Å –ø–æ–º–æ—â—å—é –±–æ–ª–µ–µ —Å–ª—É—á–∞–π–Ω–æ–≥–æ —à—É–º–∞ –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å–ª–æ—ë–≤.");
      } else if (metrics.ncc < 30) {
        recs.push("NCC –Ω–∏–∂–µ 30% ‚Äî –∫–æ—Ä—Ä–µ–ª—è—Ü–∏—è –º–∞–ª–∞. –≠—Ç–æ —Ö–æ—Ä–æ—à–æ, —á—Ç–æ–±—ã –¥–æ–±–∏—Ç—å—Å—è –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ–≥–æ –æ—Ç–ª–∏—á–∏—è –æ—Ç –æ—Ä–∏–≥–∏–Ω–∞–ª–∞.");
      }

      // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ Entropy (—ç–Ω—Ç—Ä–æ–ø–∏—è)
      if (metrics.entropy < 6) {
        recs.push("–≠–Ω—Ç—Ä–æ–ø–∏—è –Ω–∏–∑–∫–∞—è (< 6) ‚Äî —Ç–µ–∫—Å—Ç—É—Ä–∞ —à—É–º–∞ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å–ª—É—á–∞–π–Ω–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–∏–ø—ã —à—É–º–∞ —Å —Ö–∞–æ—Ç–∏—á–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π (–Ω–∞–ø—Ä–∏–º–µ—Ä, '–ò—Å–∫—Ä–∞', '–ë–µ–ª—ã–π', '–°–æ–ª—å-–ü–µ—Ä–µ—Ü').");
      } else if (metrics.entropy > 8) {
        recs.push("–≠–Ω—Ç—Ä–æ–ø–∏—è –≤—ã—Å–æ–∫–∞—è (> 8) ‚Äî —Ç–µ–∫—Å—Ç—É—Ä–∞ —à—É–º–∞ –æ—á–µ–Ω—å —Å–ª—É—á–∞–π–Ω–∞. –≠—Ç–æ –æ—Ç–ª–∏—á–Ω–æ –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è –º–∞—Å–∫–∏—Ä–æ–≤–∫–∏ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è.");
      }

      // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
      if (layers.length > 4) {
        recs.push("–£ –≤–∞—Å –±–æ–ª—å—à–µ 4 —Å–ª–æ—ë–≤ —à—É–º–∞. –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–º–µ–¥–ª—è—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ–±—ä–µ–¥–∏–Ω–∏—Ç—å —Å–ª–æ–∏ —Å –º–∞–ª—ã–º –≤–µ—Å–æ–º.");
      }

      recommendationsDiv.innerHTML = recs.length
        ? `–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:<br>‚Ä¢ ${recs.join('<br>‚Ä¢ ')}`
        : '–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã.';
    }

    function addLayer() {
      const newLayer = {
        id: Date.now(),
        noiseType: 'random',
        weight: 0.5,
        noiseLevel: 0.7,
        noiseScale: 10,
        smoothType: 'gaussian',
        smoothValue: 0,
        spots: 10,
        colorNoise: false,
        alphaLevel: 1
      };
      layers.push(newLayer);
      updateLayerUI();
      saveToHistory();
      generateNoise();
    }

    function removeLayer(id) {
      layers = layers.filter(layer => layer.id !== id);
      updateLayerUI();
      generateNoise();
      saveToHistory();
    }

    function updateSmoothInputAttributes(layerId, smoothType) {
      const input = document.querySelector(`#smoothValue-${layerId}`);
      const tooltip = input.parentElement.querySelector('.tooltip');
      if (smoothType === 'gaussian') {
        input.min = 0;
        input.max = 10;
        input.step = 0.1;
        tooltip.textContent = '–†–∞–¥–∏—É—Å –≥–∞—É—Å—Å–æ–≤–∞ —Ä–∞–∑–º—ã—Ç–∏—è (0‚Äì10)';
      } else if (smoothType === 'median') {
        input.min = 0;
        input.max = 5;
        input.step = 1;
        tooltip.textContent = '–†–∞–¥–∏—É—Å –º–µ–¥–∏–∞–Ω–Ω–æ–≥–æ —Ñ–∏–ª—å—Ç—Ä–∞ (0‚Äì5)';
      } else if (smoothType === 'bilateral') {
        input.min = 0;
        input.max = 5;
        input.step = 0.1;
        tooltip.textContent = '–°–∏–≥–º–∞ –±–∏–ª–∞—Ç–µ—Ä–∞–ª—å–Ω–æ–≥–æ —Ñ–∏–ª—å—Ç—Ä–∞ (0‚Äì5)';
      } else if (smoothType === 'anisotropic') {
        input.min = 0;
        input.max = 10;
        input.step = 0.1;
        tooltip.textContent = '–°–∏–ª–∞ –∞–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–æ–≥–æ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è (0‚Äì10)';
      } else if (smoothType === 'nonlocal') {
        input.min = 0;
        input.max = 5;
        input.step = 0.1;
        tooltip.textContent = '–°–∏–ª–∞ –Ω–µ–ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è (0‚Äì5)';
      } else if (smoothType === 'mean') {
        input.min = 0;
        input.max = 5;
        input.step = 1;
        tooltip.textContent = '–†–∞–¥–∏—É—Å —É—Å—Ä–µ–¥–Ω—è—é—â–µ–≥–æ —Ñ–∏–ª—å—Ç—Ä–∞ (0‚Äì5)';
      }
    }

    function updateLayerUI() {
      const layerList = document.getElementById('layerList');
      layerList.innerHTML = '';
      layers.forEach(layer => {
        const div = document.createElement('div');
        div.className = 'layer-item';
        div.innerHTML = `
          <div class="control-group">
            <label>–¢–∏–ø —à—É–º–∞</label>
            <select onchange="updateLayer(${layer.id}, 'noiseType', this.value)">
            <option value="perlin" ${layer.noiseType === 'perlin' ? 'selected' : ''}>–ü–µ—Ä–ª–∏–Ω–æ–≤—ã–π</option>
            <option value="simplex" ${layer.noiseType === 'simplex' ? 'selected' : ''}>–°–∏–º–ø–ª–µ–∫—Å–∞</option>
            <option value="fractal" ${layer.noiseType === 'fractal' ? 'selected' : ''}>–§—Ä–∞–∫—Ç–∞–ª—å–Ω—ã–π</option>
            <option value="cellular" ${layer.noiseType === 'cellular' ? 'selected' : ''}>–ö–ª–µ—Ç–æ—á–Ω—ã–π</option>
            <option value="voronoi" ${layer.noiseType === 'voronoi' ? 'selected' : ''}>–í–æ—Ä–æ–Ω–æ–π</option>
            <option value="billow" ${layer.noiseType === 'billow' ? 'selected' : ''}>–ë–∏–ª–ª–æ—É</option>
            <option value="ridged" ${layer.noiseType === 'ridged' ? 'selected' : ''}>–†–∏–¥–∂–µ–¥</option>
            <option value="white" ${layer.noiseType === 'white' ? 'selected' : ''}>–ë–µ–ª—ã–π</option>
            <option value="pink" ${layer.noiseType === 'pink' ? 'selected' : ''}>–†–æ–∑–æ–≤—ã–π</option>
            <option value="brown" ${layer.noiseType === 'brown' ? 'selected' : ''}>–ö–æ—Ä–∏—á–Ω–µ–≤—ã–π</option>
            <option value="blue" ${layer.noiseType === 'blue' ? 'selected' : ''}>–°–∏–Ω–∏–π</option>
            <option value="saltPepper" ${layer.noiseType === 'saltPepper' ? 'selected' : ''}>–°–æ–ª—å-–ø–µ—Ä–µ—Ü</option>
            <option value="gaussian" ${layer.noiseType === 'gaussian' ? 'selected' : ''}>–ì–∞—É—Å—Å–æ–≤</option>
            <option value="gradient" ${layer.noiseType === 'gradient' ? 'selected' : ''}>–ì—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π</option>
            <option value="sparkle" ${layer.noiseType === 'sparkle' ? 'selected' : ''}>–ò—Å–∫—Ä—ã</option>
            <option value="impulse" ${layer.noiseType === 'impulse' ? 'selected' : ''}>–ò–º–ø—É–ª—å—Å–Ω—ã–π</option>
            <option value="stripe" ${layer.noiseType === 'stripe' ? 'selected' : ''}>–ü–æ–ª–æ—Å–∞—Ç—ã–π</option>
            <option value="turbulent" ${layer.noiseType === 'turbulent' ? 'selected' : ''}>–¢—É—Ä–±—É–ª–µ–Ω—Ç–Ω—ã–π</option>
            <option value="multilayerPerlin" ${layer.noiseType === 'multilayerPerlin' ? 'selected' : ''}>–ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤—ã–π –ü–µ—Ä–ª–∏–Ω</option>
            <option value="diamondSquare" ${layer.noiseType === 'diamondSquare' ? 'selected' : ''}>–ê–ª–º–∞–∑–Ω—ã–π –∫–≤–∞–¥—Ä–∞—Ç</option>
            <option value="ridgedMultifractal" ${layer.noiseType === 'ridgedMultifractal' ? 'selected' : ''}>–†–∏–¥–∂–µ–¥ –ú—É–ª—å—Ç–∏—Ñ—Ä–∞–∫—Ç–∞–ª</option>
            <option value="midpointDisplacement" ${layer.noiseType === 'midpointDisplacement' ? 'selected' : ''}>–°–º–µ—â–µ–Ω–∏–µ —Å—Ä–µ–¥–Ω–µ–π —Ç–æ—á–∫–∏</option>
            <option value="voronoiRidged" ${layer.noiseType === 'voronoiRidged' ? 'selected' : ''}>–í–æ—Ä–æ–Ω–æ–π –†–∏–¥–∂–µ–¥</option>
            <option value="wavelet" ${layer.noiseType === 'wavelet' ? 'selected' : ''}>–í–µ–π–≤–ª–µ—Ç</option>
            <option value="erosion" ${layer.noiseType === 'erosion' ? 'selected' : ''}>–≠—Ä–æ–∑–∏—è</option>
            <option value="flow" ${layer.noiseType === 'flow' ? 'selected' : ''}>–ü–æ—Ç–æ–∫–∏</option>
            <option value="organic" ${layer.noiseType === 'organic' ? 'selected' : ''}>–û—Ä–≥–∞–Ω–∏—á–µ—Å–∫–∏–π</option>
            <option value="cloud" ${layer.noiseType === 'cloud' ? 'selected' : ''}>–û–±–ª–∞–∫–∞</option>
            <option value="lava" ${layer.noiseType === 'lava' ? 'selected' : ''}>–õ–∞–≤–∞</option>
            <option value="fabric" ${layer.noiseType === 'fabric' ? 'selected' : ''}>–¢–∫–∞–Ω—å</option>
          </select>
            <span class="tooltip">–¢–∏–ø —à—É–º–∞ –¥–ª—è —Å–ª–æ—è</span>
          </div>
          <div class="control-group">
            <label>–í–ª–∏—è–Ω–∏–µ —Å–ª–æ—è</label>
            <input type="number" value="${layer.weight}" min="0" max="1" step="0.01" onchange="updateLayer(${layer.id}, 'weight', this.value)" />
            <span class="tooltip">–í–ª–∏—è–Ω–∏–µ —Å–ª–æ—è –Ω–∞ –∏—Ç–æ–≥–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (0‚Äì1)</span>
          </div>
          <div class="control-group">
            <label>–ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å</label>
            <input type="number" value="${layer.noiseLevel}" min="0" max="1" step="0.01" onchange="updateLayer(${layer.id}, 'noiseLevel', this.value)" />
            <span class="tooltip">–û–±—â–∞—è –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —à—É–º–∞ —Å–ª–æ—è</span>
          </div>
          <div class="control-group">
            <label>–ú–∞—Å—à—Ç–∞–± —à—É–º–∞</label>
            <input type="number" value="${layer.noiseScale}" min="1" max="100" step="1" onchange="updateLayer(${layer.id}, 'noiseScale', this.value)" />
            <span class="tooltip">–†–∞–∑–º–µ—Ä –¥–µ—Ç–∞–ª–µ–π —à—É–º–∞</span>
          </div>
          <div class="control-group">
            <label>–¢–∏–ø —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è</label>
            <select onchange="updateLayer(${layer.id}, 'smoothType', this.value); updateSmoothInputAttributes(${layer.id}, this.value)">
              <option value="gaussian" ${layer.smoothType === 'gaussian' ? 'selected' : ''}>–ì–∞—É—Å—Å–æ–≤–æ</option>
              <option value="median" ${layer.smoothType === 'median' ? 'selected' : ''}>–ú–µ–¥–∏–∞–Ω–Ω–æ–µ</option>
              <option value="bilateral" ${layer.smoothType === 'bilateral' ? 'selected' : ''}>–ë–∏–ª–∞—Ç–µ—Ä–∞–ª—å–Ω–æ–µ</option>
              <option value="anisotropic" ${layer.smoothType === 'anisotropic' ? 'selected' : ''}>–ê–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–æ–µ</option>
              <option value="nonlocal" ${layer.smoothType === 'nonlocal' ? 'selected' : ''}>–ù–µ–ª–æ–∫–∞–ª—å–Ω–æ–µ</option>
              <option value="mean" ${layer.smoothType === 'mean' ? 'selected' : ''}>–£—Å—Ä–µ–¥–Ω—è—é—â–µ–µ</option>
            </select>
            <span class="tooltip">–¢–∏–ø —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è –¥–ª—è —Å–ª–æ—è</span>
          </div>
          <div class="control-group">
            <label>–°–∏–ª–∞ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è</label>
            <input id="smoothValue-${layer.id}" type="number" value="${layer.smoothValue}" onchange="updateLayer(${layer.id}, 'smoothValue', this.value)" />
            <span class="tooltip">–†–∞–¥–∏—É—Å –∏–ª–∏ —Å–∏–ª–∞ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è</span>
          </div>
          <div class="control-group">
            <label>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—è—Ç–µ–Ω</label>
            <input type="number" value="${layer.spots}" min="0" max="100" step="1" onchange="updateLayer(${layer.id}, 'spots', this.value)" />
            <span class="tooltip">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—è—Ç–µ–Ω –¥–ª—è –º–∞—Å–∫–∏</span>
          </div>
          <div class="control-group">
            <label>–¶–≤–µ—Ç–Ω–æ–π —à—É–º</label>
            <input type="checkbox" ${layer.colorNoise ? 'checked' : ''} onchange="updateLayer(${layer.id}, 'colorNoise', this.checked)" />
            <span class="tooltip">–í–∫–ª—é—á–∏—Ç—å RGB-—à—É–º</span>
          </div>
          <div class="control-group">
            <label>–ê–ª—å—Ñ–∞-–∫–∞–Ω–∞–ª</label>
            <input type="number" value="${layer.alphaLevel}" min="0" max="1" step="0.01" onchange="updateLayer(${layer.id}, 'alphaLevel', this.value)" />
            <span class="tooltip">–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å —Å–ª–æ—è (0‚Äì1)</span>
          </div>
          <div class="control-group">
            <label>–£–¥–∞–ª–∏—Ç—å —Å–ª–æ–π</label>
            <button onclick="removeLayer(${layer.id})">–£–¥–∞–ª–∏—Ç—å</button>
            <span class="tooltip">–£–¥–∞–ª—è–µ—Ç —Å–ª–æ–π</span>
          </div>
        `;
        layerList.appendChild(div);
        updateSmoothInputAttributes(layer.id, layer.smoothType);
      });
    }

    function updateLayer(id, key, value) {
      const layer = layers.find(l => l.id === id);
      if (layer) {
        layer[key] = key === 'colorNoise' ? value : key === 'smoothType' ? value : +value || value;
        generateNoise();
        saveToHistory();
      }
    }

    function saveToHistory() {
      history = history.slice(0, historyIndex + 1);
      history.push({
        layers: JSON.parse(JSON.stringify(layers)),
        canvasData: ctx.getImageData(0, 0, canvas.width, canvas.height)
      });
      historyIndex++;
      if (history.length > 50) {
        history.shift();
        historyIndex--;
      }
    }

    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        const state = history[historyIndex];
        layers = JSON.parse(JSON.stringify(state.layers));
        ctx.putImageData(state.canvasData, 0, 0);
        updateLayerUI();
      }
    }

    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        const state = history[historyIndex];
        layers = JSON.parse(JSON.stringify(state.layers));
        ctx.putImageData(state.canvasData, 0, 0);
        updateLayerUI();
      }
    }

    async function generateNoise(preview = false) {
      try {
        const startTime = performance.now();
        const widthInput = +document.getElementById('width').value;
        const heightInput = +document.getElementById('height').value;
        const width = preview ? Math.min(widthInput, 256) : widthInput;
        const height = preview ? Math.min(heightInput, 256) : heightInput;
        resizeCanvas(width, height);
        const colorPalette = document.getElementById('colorPalette').value;

        progress.style.display = 'block';
        progress.textContent = '–û–±—Ä–∞–±–æ—Ç–∫–∞: 0%';
        ctx.clearRect(0, 0, width, height);

        const finalImageData = ctx.createImageData(width, height);
        const chunkSize = Math.ceil(height / 10);

        for (let layer of layers) {
          const chunkImageData = await new Promise((resolve, reject) => {
            noiseWorker.onmessage = function (e) {
              if (e.data.error) reject(new Error(e.data.error));
              else resolve(e.data.imgData);
            };
            noiseWorker.onerror = function (e) {
              reject(new Error('–û—à–∏–±–∫–∞ –≤ Web Worker: ' + e.message));
            };
            noiseWorker.postMessage({
              width,
              height,
              layer: {
                ...layer,
                noiseLevel: layer.noiseLevel * (1 + Math.random() * 0.5), // –†–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏—è –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç–∏
                alphaLevel: Math.min(1, layer.alphaLevel * 1.2), // –£–≤–µ–ª–∏—á–µ–Ω–∏–µ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏
              },
              spots: layer.spots || 10,
              colorPalette,
            });
          });

          for (let i = 0; i < finalImageData.data.length; i += 4) {
            finalImageData.data[i] += chunkImageData.data[i] * (layer.weight * 1.5); // –£–≤–µ–ª–∏—á–µ–Ω–∏–µ –≤–µ—Å–∞
            finalImageData.data[i + 1] += chunkImageData.data[i + 1] * (layer.weight * 1.5);
            finalImageData.data[i + 2] += chunkImageData.data[i + 2] * (layer.weight * 1.5);
            finalImageData.data[i + 3] += chunkImageData.data[i + 3] * (layer.weight * 1.5);
          }

          for (let y = 0; y < height; y += chunkSize) {
            const chunkHeight = Math.min(chunkSize, height - y);
            const chunkData = ctx.createImageData(width, chunkHeight);
            for (let cy = 0; cy < chunkHeight; cy++) {
              for (let x = 0; x < width; x++) {
                const srcIndex = ((y + cy) * width + x) * 4;
                const dstIndex = (cy * width + x) * 4;
                chunkData.data[dstIndex] = finalImageData.data[srcIndex];
                chunkData.data[dstIndex + 1] = finalImageData.data[srcIndex + 1];
                chunkData.data[dstIndex + 2] = finalImageData.data[srcIndex + 2];
                chunkData.data[dstIndex + 3] = finalImageData.data[srcIndex + 3];
              }
            }
            ctx.putImageData(chunkData, 0, y);
            progress.textContent = `–û–±—Ä–∞–±–æ—Ç–∫–∞: ${Math.round((y + chunkHeight) / height * 100)}%`;
            await new Promise(resolve => requestAnimationFrame(resolve));
          }
        }

        ctx.putImageData(finalImageData, 0, 0);
        progress.style.display = 'none';


        const endTime = performance.now();
        const generationTime = (endTime - startTime).toFixed(2);

        const metrics = calculateMetrics(finalImageData, width, height);
        metricsDiv.textContent = `SSIM: ${metrics.ssim.toFixed(2)}%, PSNR: ${metrics.psnr.toFixed(2)} dB, RMSE: ${metrics.rmse.toFixed(2)}, MAE: ${metrics.mae.toFixed(2)}, AE: ${metrics.ae.toFixed(2)}, NCC: ${metrics.ncc.toFixed(2)}%, Entropy: ${metrics.entropy.toFixed(2)}, –í—Ä–µ–º—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: ${generationTime} –º—Å`; updateRecommendations(metrics, generationTime);

        saveToHistory();
      } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:', error);
        progress.textContent = '–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏';
        progress.style.display = 'block';
      }
    }

    async function previewNoise() {
      await generateNoise(true);
    }

    function download(name = 'noise.png') {
      const link = document.createElement('a');
      link.download = name;
      link.href = canvas.toDataURL();
      link.click();
    }

    async function saveCopies() {
      const count = +copiesInput.value || 5;
      progress.style.display = 'block';
      for (let i = 0; i < count; i++) {
        await generateNoise();
        progress.textContent = `–û–±—Ä–∞–±–æ—Ç–∫–∞: ${Math.round((i + 1) / count * 100)}%`;
        await new Promise(resolve => setTimeout(resolve, 100));
        download(`noise${i + 1}.png`);
      }
      progress.style.display = 'none';
    }

    function saveSettings() {
      const settings = {
        width: document.getElementById('width').value,
        height: document.getElementById('height').value,
        layers,
        colorPalette: document.getElementById('colorPalette').value,
        copies: copiesInput.value
      };
      const presetName = prompt('–í–≤–µ–¥–∏—Ç–µ –∏–º—è –ø—Ä–µ—Å–µ—Ç–∞:') || 'default';
      let presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      presets[presetName] = settings;
      localStorage.setItem('noisePresets', JSON.stringify(presets));
      alert('–ü—Ä–µ—Å–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω!');
    }

    function loadPresets() {
      const presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      const presetName = prompt('–í–≤–µ–¥–∏—Ç–µ –∏–º—è –ø—Ä–µ—Å–µ—Ç–∞ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏:\n–î–æ—Å—Ç—É–ø–Ω—ã–µ: ' + Object.keys(presets).join(', '));
      if (presets[presetName]) {
        const settings = presets[presetName];
        document.getElementById('width').value = settings.width || 512;
        document.getElementById('height').value = settings.height || 1024;
        document.getElementById('colorPalette').value = settings.colorPalette || '#ffffff';
        layers = settings.layers || [{
          id: Date.now(),
          noiseType: 'perlin',
          weight: 1,
          noiseLevel: 0.7,
          noiseScale: 10,
          smoothType: 'gaussian',
          smoothValue: 0,
          spots: 10,
          colorNoise: false,
          alphaLevel: 1
        }];
        copiesInput.value = settings.copies || 5;
        copiesDisplay.textContent = settings.copies || 5;
        updateLayerUI();
        generateNoise();
      } else {
        alert('–ü—Ä–µ—Å–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω!');
      }
    }

    copiesInput.addEventListener('input', () => {
      copiesDisplay.textContent = copiesInput.value;
    });

    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    const inputs = document.querySelectorAll('input, select');
    inputs.forEach(input => {
      input.addEventListener('input', debounce(generateNoise, 300));
    });

    window.addEventListener('resize', generateNoise);
    updateLayerUI();
    generateNoise();


    function openPresetModal() {
      document.getElementById("presetModal").style.display = "block";
      updatePresetList();
    }

    function closePresetModal() {
      document.getElementById("presetModal").style.display = "none";
    }

    document.getElementById("savePresetButton").addEventListener("click", function () {
      const nameInput = document.getElementById("presetNameInput");
      const presetName = nameInput.value.trim();
      if (!presetName) return;

      const settings = {
        width: document.getElementById('width').value,
        height: document.getElementById('height').value,
        layers,
        colorPalette: document.getElementById('colorPalette').value,
        copies: copiesInput.value
      };

      let presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      presets[presetName] = settings;
      localStorage.setItem('noisePresets', JSON.stringify(presets));

      nameInput.value = '';
      updatePresetList();
    });

    function loadPreset(presetName) {
      const presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      const settings = presets[presetName];
      if (!settings) return;

      document.getElementById('width').value = settings.width || 512;
      document.getElementById('height').value = settings.height || 1024;
      document.getElementById('colorPalette').value = settings.colorPalette || '#ffffff';
      layers = settings.layers || getDefaultLayers();
      copiesInput.value = settings.copies || 5;
      copiesDisplay.textContent = settings.copies || 5;

      updateLayerUI();
      generateNoise();
      closePresetModal();
    }

    function deletePreset(presetName) {
      if (!confirm(`–£–¥–∞–ª–∏—Ç—å –ø—Ä–µ—Å–µ—Ç "${presetName}"? –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ.`)) return;
      let presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      delete presets[presetName];
      localStorage.setItem('noisePresets', JSON.stringify(presets));
      updatePresetList();
    }

    function updatePresetList() {

      const listContainer = document.getElementById("presetList");
      listContainer.innerHTML = "";

      const presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      const sortedNames = Object.keys(presets).sort();

      sortedNames.forEach(name => {
        const card = document.createElement("div");
        card.className = "preset-card";

        const title = document.createElement("div");
        title.textContent = name;

        const loadBtn = document.createElement("button");
        loadBtn.textContent = "–ó–∞–≥—Ä—É–∑–∏—Ç—å";
        loadBtn.className = "load";
        loadBtn.onclick = () => loadPreset(name);

        const deleteBtn = document.createElement("button");
        deleteBtn.textContent = "–£–¥–∞–ª–∏—Ç—å";
        deleteBtn.className = "delete";
        deleteBtn.onclick = () => deletePreset(name);

        card.appendChild(title);
        card.appendChild(loadBtn);
        card.appendChild(deleteBtn);
        listContainer.appendChild(card);
      });
    }

    document.getElementById("closeModal").addEventListener("click", closePresetModal);
    document.getElementById("openPresetModalButton").addEventListener("click", openPresetModal);
    window.onclick = function (event) {
      if (event.target == document.getElementById("presetModal")) closePresetModal();
    };

    function getDefaultLayers() {
      return [{
        id: Date.now(),
        noiseType: 'random',
        weight: 0.5,
        noiseLevel: 0.7,
        noiseScale: 10,
        smoothType: 'gaussian',
        smoothValue: 0,
        spots: 10,
        colorNoise: false,
        alphaLevel: 1
      }];
    }

    function initializePresets() {
      const defaultPresets = [
        {
          "name": "–°–æ–ª—å-–ø–µ—Ä–µ—Ü + –ò—Å–∫—Ä—ã",
          "width": 512,
          "height": 1024,
          "colorPalette": "#ffffff",
          "copies": 5,
          "layers": [
            {
              "noiseType": "saltPepper",
              "weight": 0.6,
              "noiseLevel": 1,
              "spots": 20,
              "colorNoise": false,
              "alphaLevel": 1,
              "smoothType": "none",
              "smoothValue": 0
            },
            {
              "noiseType": "sparkle",
              "weight": 0.4,
              "noiseLevel": 1,
              "noiseScale": 10,
              "spots": 15,
              "colorNoise": true,
              "alphaLevel": 1,
              "smoothType": "none",
              "smoothValue": 0
            }
          ]
        },
        {
          "name": "–¶–≤–µ—Ç–Ω–æ–π –±–µ–ª—ã–π —à—É–º + –ì—Ä–∞–¥–∏–µ–Ω—Ç",
          "width": 512,
          "height": 1024,
          "colorPalette": "#ff0000",
          "copies": 5,
          "layers": [
            {
              "noiseType": "white",
              "weight": 0.7,
              "noiseLevel": 1,
              "spots": 0,
              "colorNoise": true,
              "alphaLevel": 1,
              "smoothType": "none",
              "smoothValue": 0
            },
            {
              "noiseType": "gradient",
              "weight": 0.3,
              "noiseLevel": 1,
              "noiseScale": 5,
              "spots": 0,
              "colorNoise": true,
              "alphaLevel": 1,
              "smoothType": "none",
              "smoothValue": 0
            }
          ]
        },
        {
          "name": "–ú–Ω–æ–≥–æ—Å–ª–æ–π–Ω—ã–π —Ö–∞–æ—Å",
          "width": 512,
          "height": 1024,
          "colorPalette": "#00ffff",
          "copies": 5,
          "layers": [
            {
              "noiseType": "saltPepper",
              "weight": 0.4,
              "noiseLevel": 1,
              "spots": 20,
              "colorNoise": false,
              "alphaLevel": 1,
              "smoothType": "none",
              "smoothValue": 0
            },
            {
              "noiseType": "white",
              "weight": 0.3,
              "noiseLevel": 1,
              "spots": 0,
              "colorNoise": true,
              "alphaLevel": 1,
              "smoothType": "none",
              "smoothValue": 0
            },
            {
              "noiseType": "sparkle",
              "weight": 0.2,
              "noiseLevel": 1,
              "noiseScale": 8,
              "spots": 10,
              "colorNoise": true,
              "alphaLevel": 1,
              "smoothType": "none",
              "smoothValue": 0
            },
            {
              "noiseType": "gaussian",
              "weight": 0.1,
              "noiseLevel": 1,
              "noiseScale": 10,
              "spots": 0,
              "colorNoise": true,
              "alphaLevel": 0.9,
              "smoothType": "none",
              "smoothValue": 0
            }
          ]
        },
        {
          "name": "–•–∞–æ—Ç–∏—á–Ω—ã–π —à—Ç–æ—Ä–º",
          "width": 512,
          "height": 1024,
          "colorPalette": "#ff0000",
          "copies": 5,
          "layers": [
            {
              "id": 1,
              "noiseType": "impulse",
              "weight": 0.9,
              "noiseLevel": 1.0,
              "noiseScale": 5,
              "smoothType": "none",
              "smoothValue": 0,
              "spots": 20,
              "colorNoise": true,
              "alphaLevel": 1.0
            },
            {
              "id": 2,
              "noiseType": "turbulent",
              "weight": 0.7,
              "noiseLevel": 0.9,
              "noiseScale": 10,
              "smoothType": "gaussian",
              "smoothValue": 0.5,
              "spots": 15,
              "colorNoise": true,
              "alphaLevel": 0.9
            }
          ]
        },
        {
          "name": "–ì–æ—Ä–Ω—ã–π —Ö–∞–æ—Å",
          "width": 512,
          "height": 1024,
          "colorPalette": "#00ff00",
          "copies": 5,
          "layers": [
            {
              "id": 1,
              "noiseType": "ridgedMultifractal",
              "weight": 1.0,
              "noiseLevel": 1.0,
              "noiseScale": 8,
              "smoothType": "none",
              "smoothValue": 0,
              "spots": 25,
              "colorNoise": false,
              "alphaLevel": 1.0
            },
            {
              "id": 2,
              "noiseType": "diamondSquare",
              "weight": 0.8,
              "noiseLevel": 0.9,
              "noiseScale": 15,
              "smoothType": "none",
              "smoothValue": 0,
              "spots": 20,
              "colorNoise": false,
              "alphaLevel": 0.9
            }
          ]
        },
        {
          "name": "–ü–æ–ª–æ—Å–∞—Ç—ã–π –≤–∏—Ö—Ä—å",
          "width": 512,
          "height": 1024,
          "colorPalette": "#0000ff",
          "copies": 5,
          "layers": [
            {
              "id": 1,
              "noiseType": "stripe",
              "weight": 0.9,
              "noiseLevel": 1.0,
              "noiseScale": 10,
              "smoothType": "none",
              "smoothValue": 0,
              "spots": 20,
              "colorNoise": true,
              "alphaLevel": 1.0
            },
            {
              "id": 2,
              "noiseType": "multilayerPerlin",
              "weight": 0.7,
              "noiseLevel": 0.9,
              "noiseScale": 12,
              "smoothType": "gaussian",
              "smoothValue": 0.3,
              "spots": 15,
              "colorNoise": true,
              "alphaLevel": 0.9
            }
          ]
        },
        {
          "name": "–°–æ–ª—è–Ω–æ–π –≤–∑—Ä—ã–≤",
          "width": 512,
          "height": 1024,
          "colorPalette": "#ffffff",
          "copies": 5,
          "layers": [
            {
              "id": 1,
              "noiseType": "saltPepper",
              "weight": 1.0,
              "noiseLevel": 1.0,
              "noiseScale": 5,
              "smoothType": "none",
              "smoothValue": 0,
              "spots": 30,
              "colorNoise": true,
              "alphaLevel": 1.0
            },
            {
              "id": 2,
              "noiseType": "turbulent",
              "weight": 0.8,
              "noiseLevel": 0.9,
              "noiseScale": 10,
              "smoothType": "none",
              "smoothValue": 0,
              "spots": 20,
              "colorNoise": true,
              "alphaLevel": 0.9
            }
          ]
        },
        {
          "name": "–§—Ä–∞–∫—Ç–∞–ª—å–Ω–∞—è –±—É—Ä—è",
          "width": 512,
          "height": 1024,
          "colorPalette": "#ff00ff",
          "copies": 5,
          "layers": [
            {
              "id": 1,
              "noiseType": "fractal",
              "weight": 0.9,
              "noiseLevel": 1.0,
              "noiseScale": 8,
              "smoothType": "none",
              "smoothValue": 0,
              "spots": 25,
              "colorNoise": true,
              "alphaLevel": 1.0
            },
            {
              "id": 2,
              "noiseType": "ridgedMultifractal",
              "weight": 0.8,
              "noiseLevel": 0.9,
              "noiseScale": 10,
              "smoothType": "gaussian",
              "smoothValue": 0.5,
              "spots": 20,
              "colorNoise": true,
              "alphaLevel": 0.9
            }
          ]
        },
        {
          "name": "–ö–ª–µ—Ç–æ—á–Ω–∞—è –∞–Ω–æ–º–∞–ª–∏—è",
          "width": 512,
          "height": 1024,
          "colorPalette": "#00ffff",
          "copies": 5,
          "layers": [
            {
              "id": 1,
              "noiseType": "cellular",
              "weight": 1.0,
              "noiseLevel": 1.0,
              "noiseScale": 10,
              "smoothType": "none",
              "smoothValue": 0,
              "spots": 25,
              "colorNoise": true,
              "alphaLevel": 1.0
            },
            {
              "id": 2,
              "noiseType": "impulse",
              "weight": 0.7,
              "noiseLevel": 0.9,
              "noiseScale": 5,
              "smoothType": "none",
              "smoothValue": 0,
              "spots": 20,
              "colorNoise": true,
              "alphaLevel": 0.9
            }
          ]
        },
        {
          "name": "–í–æ—Ä–æ–Ω–æ–π —Ä–∞–∑–ª–æ–º",
          "width": 512,
          "height": 1024,
          "colorPalette": "#ffff00",
          "copies": 5,
          "layers": [
            {
              "id": 1,
              "noiseType": "voronoi",
              "weight": 0.9,
              "noiseLevel": 1.0,
              "noiseScale": 12,
              "smoothType": "none",
              "smoothValue": 0,
              "spots": 20,
              "colorNoise": false,
              "alphaLevel": 1.0
            },
            {
              "id": 2,
              "noiseType": "diamondSquare",
              "weight": 0.8,
              "noiseLevel": 0.9,
              "noiseScale": 15,
              "smoothType": "gaussian",
              "smoothValue": 0.3,
              "spots": 15,
              "colorNoise": false,
              "alphaLevel": 0.9
            }
          ]
        },
        {
          "name": "–ë–µ–ª—ã–π —É—Ä–∞–≥–∞–Ω",
          "width": 512,
          "height": 1024,
          "colorPalette": "#ffffff",
          "copies": 5,
          "layers": [
            {
              "id": 1,
              "noiseType": "white",
              "weight": 1.0,
              "noiseLevel": 1.0,
              "noiseScale": 5,
              "smoothType": "none",
              "smoothValue": 0,
              "spots": 30,
              "colorNoise": true,
              "alphaLevel": 1.0
            },
            {
              "id": 2,
              "noiseType": "turbulent",
              "weight": 0.8,
              "noiseLevel": 0.9,
              "noiseScale": 10,
              "smoothType": "none",
              "smoothValue": 0,
              "spots": 20,
              "colorNoise": true,
              "alphaLevel": 0.9
            }
          ]
        },
        {
          "name": "–ò—Å–∫—Ä—ã –≤ –ø—É—Å—Ç—ã–Ω–µ",
          "width": 512,
          "height": 1024,
          "colorPalette": "#ffaa00",
          "copies": 5,
          "layers": [
            {
              "id": 1,
              "noiseType": "sparkle",
              "weight": 0.9,
              "noiseLevel": 1.0,
              "noiseScale": 8,
              "smoothType": "none",
              "smoothValue": 0,
              "spots": 25,
              "colorNoise": true,
              "alphaLevel": 1.0
            },
            {
              "id": 2,
              "noiseType": "multilayerPerlin",
              "weight": 0.7,
              "noiseLevel": 0.9,
              "noiseScale": 15,
              "smoothType": "gaussian",
              "smoothValue": 0.5,
              "spots": 20,
              "colorNoise": true,
              "alphaLevel": 0.9
            }
          ]
        },
        {
          "name": "–ì–∞—É—Å—Å–æ–≤ —Ä–∞–∑—Ä—ã–≤",
          "width": 512,
          "height": 1024,
          "colorPalette": "#aa00ff",
          "copies": 5,
          "layers": [
            {
              "id": 1,
              "noiseType": "gaussian",
              "weight": 1.0,
              "noiseLevel": 1.0,
              "noiseScale": 10,
              "smoothType": "none",
              "smoothValue": 0,
              "spots": 25,
              "colorNoise": true,
              "alphaLevel": 1.0
            },
            {
              "id": 2,
              "noiseType": "ridgedMultifractal",
              "weight": 0.8,
              "noiseLevel": 0.9,
              "noiseScale": 8,
              "smoothType": "none",
              "smoothValue": 0,
              "spots": 20,
              "colorNoise": true,
              "alphaLevel": 0.9
            }
          ]
        },
        {
          "name": "–•–∞–æ—Ç–∏—á–Ω—ã–π –ª–∞–Ω–¥—à–∞—Ñ—Ç",
          "layers": [
            {
              "noiseType": "midpointDisplacement",
              "noiseLevel": 0.9,
              "noiseScale": 15,
              "weight": 0.8,
              "alphaLevel": 1.0,
              "colorNoise": false,
              "spots": 30
            },
            {
              "noiseType": "voronoiRidged",
              "noiseLevel": 0.8,
              "noiseScale": 10,
              "weight": 0.7,
              "alphaLevel": 0.9,
              "colorNoise": true,
              "spots": 20
            },
            {
              "noiseType": "impulse",
              "noiseLevel": 1.0,
              "noiseScale": 5,
              "weight": 0.6,
              "alphaLevel": 0.8,
              "colorNoise": true,
              "spots": 40
            }
          ],
          "smoothValue": 0
        },
        {
          "name": "–¢—É—Ä–±—É–ª–µ–Ω—Ç–Ω–∞—è –∞—Ç–º–æ—Å—Ñ–µ—Ä–∞",
          "layers": [
            {
              "noiseType": "cloud",
              "noiseLevel": 0.8,
              "noiseScale": 20,
              "weight": 0.7,
              "alphaLevel": 0.9,
              "colorNoise": true,
              "spots": 25
            },
            {
              "noiseType": "turbulent",
              "noiseLevel": 0.9,
              "noiseScale": 10,
              "weight": 0.8,
              "alphaLevel": 1.0,
              "colorNoise": true,
              "spots": 30
            },
            {
              "noiseType": "wavelet",
              "noiseLevel": 0.7,
              "noiseScale": 5,
              "weight": 0.6,
              "alphaLevel": 0.8,
              "colorNoise": true,
              "spots": 35
            }
          ],
          "smoothValue": 0.3
        },
        {
          "name": "–û—Ä–≥–∞–Ω–∏—á–µ—Å–∫–∏–π —Ö–∞–æ—Å",
          "layers": [
            {
              "noiseType": "organic",
              "noiseLevel": 0.9,
              "noiseScale": 10,
              "weight": 0.8,
              "alphaLevel": 1.0,
              "colorNoise": true,
              "spots": 30
            },
            {
              "noiseType": "flow",
              "noiseLevel": 0.8,
              "noiseScale": 15,
              "weight": 0.7,
              "alphaLevel": 0.9,
              "colorNoise": true,
              "spots": 25
            },
            {
              "noiseType": "saltPepper",
              "noiseLevel": 1.0,
              "noiseScale": 5,
              "weight": 0.6,
              "alphaLevel": 0.8,
              "colorNoise": true,
              "spots": 40
            }
          ],
          "smoothValue": 0
        },
        {
          "name": "–û–≥–Ω–µ–Ω–Ω–∞—è –±—É—Ä—è",
          "layers": [
            {
              "noiseType": "lava",
              "noiseLevel": 0.9,
              "noiseScale": 10,
              "weight": 0.8,
              "alphaLevel": 1.0,
              "colorNoise": true,
              "spots": 30
            },
            {
              "noiseType": "ridgedMultifractal",
              "noiseLevel": 0.8,
              "noiseScale": 15,
              "weight": 0.7,
              "alphaLevel": 0.9,
              "colorNoise": true,
              "spots": 25
            },
            {
              "noiseType": "sparkle",
              "noiseLevel": 0.7,
              "noiseScale": 5,
              "weight": 0.6,
              "alphaLevel": 0.8,
              "colorNoise": true,
              "spots": 35
            }
          ],
          "smoothValue": 0.2
        },
        {
          "name": "–¢–µ–∫—Å—Ç–∏–ª—å–Ω—ã–π –ª–∞–Ω–¥—à–∞—Ñ—Ç",
          "layers": [
            {
              "noiseType": "fabric",
              "noiseLevel": 0.8,
              "noiseScale": 10,
              "weight": 0.7,
              "alphaLevel": 0.9,
              "colorNoise": true,
              "spots": 25
            },
            {
              "noiseType": "erosion",
              "noiseLevel": 0.9,
              "noiseScale": 15,
              "weight": 0.8,
              "alphaLevel": 1.0,
              "colorNoise": true,
              "spots": 30
            },
            {
              "noiseType": "stripe",
              "noiseLevel": 0.7,
              "noiseScale": 5,
              "weight": 0.6,
              "alphaLevel": 0.8,
              "colorNoise": true,
              "spots": 40
            }
          ],
          "smoothValue": 0.3
        }


      ];
      let presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      defaultPresets.forEach(preset => {
        presets[preset.name] = preset;
      });
      localStorage.setItem('noisePresets', JSON.stringify(presets));
      updatePresetList();
    }
    // –í—ã–∑–æ–≤–∏ initializePresets() –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    initializePresets();

  </script>
</body>

</html>
