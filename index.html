<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —à—É–º–∞</title>
  <style>
    :root {
      --bg-color: #222;
      --card-bg: #333;
      --text-color: #ffffff;
      --accent-color: #1465ac;
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      --border-radius: 12px;
    }

    body {
      background: var(--bg-color);
      color: var(--text-color);
      font-family: -apple-system, BlinkMacSystemFont, 'system-ui', sans-serif;
      margin: 0;
      padding: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      overflow-y: auto;
      box-sizing: border-box;
    }

    .container {
      max-width: 1200px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 16px;
      max-height: 100vh;
      box-sizing: border-box;
    }

    .canvas-container {
      position: relative;
      width: 100%;
      display: flex;
      justify-content: center;
    }

    canvas {
      border: 1px solid #555;
      border-radius: var(--border-radius);
      max-height: calc(100vh - 320px);
      width: 100%;
      object-fit: contain;
      background: #000;
      box-shadow: var(--shadow);
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      padding: 12px;
      background: var(--card-bg);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
      position: relative;
    }

    label {
      font-size: 14px;
      font-weight: 500;
      opacity: 0.9;
    }

    input[type="number"],
    select,
    input[type="checkbox"],
    input[type="color"] {
      background: #666;
      border: none;
      border-radius: 8px;
      padding: 8px;
      color: var(--text-color);
      font-size: 14px;
      transition: background 0.2s;
      width: 100%;
      box-sizing: border-box;
    }

    input[type="number"]:hover,
    select:hover,
    input[type="color"]:hover {
      background: #4a545c;
    }

    button {
      background: var(--accent-color);
      border: none;
      border-radius: 7px;
      padding: 10px 16px;
      color: white;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: transform 0.1s, background 0.2s;
      box-shadow: var(--shadow);
    }

    button:hover {
      background: #082f51;
      transform: scale(1.04);
    }

    button:active {
      transform: scale(0.95);
    }

    .actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
      padding: 12px;
      background: var(--card-bg);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
    }

    .layers {
      padding: 12px;
      background: var(--card-bg);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
    }

    .layer-item {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      padding: 8px;
      border-bottom: 1px solid #555;
    }

    #progress,
    #metrics,
    #recommendations {
      font-size: 14px;
      padding: 12px;
      background: var(--card-bg);
      border-radius: var(--border-radius);
      text-align: center;
      box-shadow: var(--shadow);
    }

    #progress {
      display: none;
    }

    #metrics,
    #recommendations {
      display: block;
      font-size: 13px;
      opacity: 0.9;
    }

    .tooltip {
      visibility: hidden;
      background: #000;
      color: white;
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 6px;
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      white-space: nowrap;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .control-group:hover .tooltip {
      visibility: visible;
      opacity: 1;
    }

    @media (max-width: 600px) {

      .controls,
      .layer-item {
        grid-template-columns: 1fr;
      }

      canvas {
        max-height: calc(100vh - 400px);
      }
    }

    /* –°—Ç–∏–ª–∏ –¥–ª—è –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
    }

    .modal-content {
      background-color: #2e2e2e;
      margin: 5% auto;
      padding: 20px;
      border-radius: 12px;
      width: 80%;
      max-width: 600px;
      color: white;
      font-family: sans-serif;
      box-shadow: 0 0 15px black;
      animation: fadeIn 0.3s ease-out;
    }

    .close {
      float: right;
      font-size: 28px;
      cursor: pointer;
    }

    .save-section,
    .load-section {
      margin-top: 20px;
    }

    .preset-list {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .preset-card {
      background: #444;
      border-radius: 8px;
      padding: 10px;
      width: 150px;
      text-align: center;
      box-shadow: 0 0 5px black;
    }

    .preset-card button {
      margin-top: 5px;
      width: 100%;
      padding: 4px;
      border: none;
      cursor: pointer;
    }

    .preset-card button.load {
      background-color: #2ecc71;
      color: white;
    }

    .preset-card button.delete {
      background-color: #e74c3c;
      color: white;

    }

    #presetNameInput {
      padding: 10px;
      border-radius: 5px;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  </style>
</head>

<body>
  <!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ -->
  <div id="presetModal" class="modal">
    <div class="modal-content">
      <span id="closeModal" class="close">&times;</span>
      <h2>üéõ –ú–µ–Ω—é –ø—Ä–µ—Å–µ—Ç–æ–≤</h2>

      <div class="save-section">
        <h3>üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–æ–≤—ã–π –ø—Ä–µ—Å–µ—Ç</h3>
        <input type="text" id="presetNameInput" placeholder="–ò–º—è –ø—Ä–µ—Å–µ—Ç–∞" />
        <button id="savePresetButton">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
      </div>

      <div class="load-section">
        <h3>üìö –ó–∞–≥—Ä—É–∑–∏—Ç—å/–£–¥–∞–ª–∏—Ç—å –ø—Ä–µ—Å–µ—Ç</h3>
        <div id="presetList" class="preset-list"></div>
      </div>
    </div>
  </div>

  <div class="container">
    <button id="openPresetModalButton">–ú–µ–Ω—é –ø—Ä–µ—Å–µ—Ç–æ–≤</button>

    <div class="controls">
      <div class="control-group">
        <label>–®–∏—Ä–∏–Ω–∞</label>
        <input type="number" id="width" value="512" min="1" />
        <span class="tooltip">–®–∏—Ä–∏–Ω–∞ —à—É–º–∞ –≤ –ø–∏–∫—Å–µ–ª—è—Ö</span>
      </div>
      <div class="control-group">
        <label>–í—ã—Å–æ—Ç–∞</label>
        <input type="number" id="height" value="1024" min="1" />
        <span class="tooltip">–í—ã—Å–æ—Ç–∞ —à—É–º–∞ –≤ –ø–∏–∫—Å–µ–ª—è—Ö</span>
      </div>
      <div class="control-group">
        <label>–¶–≤–µ—Ç —à—É–º–∞</label>
        <input type="color" id="colorPalette" value="#ffffff" />
        <span class="tooltip">–û—Å–Ω–æ–≤–Ω–æ–π —Ü–≤–µ—Ç –¥–ª—è —Ü–≤–µ—Ç–Ω–æ–≥–æ —à—É–º–∞</span>
      </div>
    </div>

    <div id="metrics">SSIM: -, PSNR: -, RMSE: -, MAE: -, Entropy: -</div>

    <div class="layers">
      <button onclick="addLayer()">–î–æ–±–∞–≤–∏—Ç—å —Å–ª–æ–π</button>
      <div id="layerList"></div>
    </div>

    <div id="progress">–û–±—Ä–∞–±–æ—Ç–∫–∞: 0%</div>

    <div class="canvas-container">
      <canvas id="noiseCanvas"></canvas>
    </div>

    <div id="recommendations">–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏: -</div>

    <div class="actions">
      <button onclick="generateNoise()">üé≤ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å</button>
      <button onclick="download()">üíæ –°–∫–∞—á–∞—Ç—å</button>
      <button onclick="saveCopies()">üìÅ –°–∫–∞—á–∞—Ç—å <span id="copiesDisplay">5</span> –∫–æ–ø–∏–π:</button>
      <input type="number" id="copies" value="5" min="1" style="width: 60px;" />
      <button onclick="undo()">‚Ü©Ô∏è –û—Ç–º–µ–Ω–∏—Ç—å</button>
      <button onclick="redo()">‚Ü™Ô∏è –í–µ—Ä–Ω—É—Ç—å</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('noiseCanvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const progress = document.getElementById('progress');
    const metricsDiv = document.getElementById('metrics');
    const recommendationsDiv = document.getElementById('recommendations');
    const copiesInput = document.getElementById('copies');
    const copiesDisplay = document.getElementById('copiesDisplay');
    let history = [];
    let historyIndex = -1;
    let layers = [{
      id: Date.now(),
      noiseType: 'random',
      weight: 0.5,
      noiseLevel: 0.7,
      noiseScale: 10,
      smoothType: 'gaussian',
      smoothValue: 0,
      spots: 10,
      colorNoise: false,
      alphaLevel: 1
    }];

    // Web Worker
    const noiseWorker = new Worker(URL.createObjectURL(new Blob([`
      function gaussianBlur(imgData, width, height, radius) {
        if (radius <= 0) return imgData;
        const kernelSize = Math.ceil(radius) * 2 + 1;
        const kernel = [];
        let sum = 0;
        const sigma = radius / 3;

        for (let i = -Math.floor(kernelSize / 2); i <= Math.floor(kernelSize / 2); i++) {
          const value = Math.exp(-(i * i) / (2 * sigma * sigma));
          kernel.push(value);
          sum += value;
        }
        for (let i = 0; i < kernel.length; i++) kernel[i] /= sum;

        const tempData = new Uint8ClampedArray(imgData.data);
        const outputData = new Uint8ClampedArray(imgData.data);

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let r = 0, g = 0, b = 0, a = 0;
            for (let i = 0; i < kernel.length; i++) {
              const offsetX = x + i - Math.floor(kernelSize / 2);
              if (offsetX >= 0 && offsetX < width) {
                const index = (y * width + offsetX) * 4;
                const weight = kernel[i];
                r += tempData[index] * weight;
                g += tempData[index + 1] * weight;
                b += tempData[index + 2] * weight;
                a += tempData[index + 3] * weight;
              }
            }
            const index = (y * width + x) * 4;
            outputData[index] = r;
            outputData[index + 1] = g;
            outputData[index + 2] = b;
            outputData[index + 3] = a;
          }
        }

        for (let x = 0; x < width; x++) {
          for (let y = 0; y < height; y++) {
            let r = 0, g = 0, b = 0, a = 0;
            for (let i = 0; i < kernel.length; i++) {
              const offsetY = y + i - Math.floor(kernelSize / 2);
              if (offsetY >= 0 && offsetY < height) {
                const index = (offsetY * width + x) * 4;
                const weight = kernel[i];
                r += outputData[index] * weight;
                g += outputData[index + 1] * weight;
                b += outputData[index + 2] * weight;
                a += outputData[index + 3] * weight;
              }
            }
            const index = (y * width + x) * 4;
            imgData.data[index] = r;
            imgData.data[index + 1] = g;
            imgData.data[index + 2] = b;
            imgData.data[index + 3] = a;
          }
        }
        return imgData;
      }

      function medianFilter(imgData, width, height, radius) {
        if (radius <= 0) return imgData;
        const kernelSize = radius * 2 + 1;
        const outputData = new Uint8ClampedArray(imgData.data);

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const rValues = [], gValues = [], bValues = [], aValues = [];
            for (let ky = -radius; ky <= radius; ky++) {
              for (let kx = -radius; kx <= radius; kx++) {
                const nx = x + kx;
                const ny = y + ky;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                  const index = (ny * width + nx) * 4;
                  rValues.push(imgData.data[index]);
                  gValues.push(imgData.data[index + 1]);
                  bValues.push(imgData.data[index + 2]);
                  aValues.push(imgData.data[index + 3]);
                }
              }
            }
            rValues.sort((a, b) => a - b);
            gValues.sort((a, b) => a - b);
            bValues.sort((a, b) => a - b);
            aValues.sort((a, b) => a - b);
            const index = (y * width + x) * 4;
            outputData[index] = rValues[Math.floor(rValues.length / 2)];
            outputData[index + 1] = gValues[Math.floor(gValues.length / 2)];
            outputData[index + 2] = bValues[Math.floor(bValues.length / 2)];
            outputData[index + 3] = aValues[Math.floor(aValues.length / 2)];
          }
        }
        imgData.data.set(outputData);
        return imgData;
      }

      function bilateralFilter(imgData, width, height, sigma) {
        if (sigma <= 0) return imgData;
        const kernelSize = Math.ceil(sigma * 3) * 2 + 1;
        const outputData = new Uint8ClampedArray(imgData.data);
        const spatialKernel = [];
        let spatialSum = 0;

        for (let i = -Math.floor(kernelSize / 2); i <= Math.floor(kernelSize / 2); i++) {
          const value = Math.exp(-(i * i) / (2 * sigma * sigma));
          spatialKernel.push(value);
          spatialSum += value;
        }
        for (let i = 0; i < spatialKernel.length; i++) spatialKernel[i] /= spatialSum;

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let rSum = 0, gSum = 0, bSum = 0, aSum = 0, weightSum = 0;
            const centerIndex = (y * width + x) * 4;
            const centerR = imgData.data[centerIndex];
            const centerG = imgData.data[centerIndex + 1];
            const centerB = imgData.data[centerIndex + 2];
            const centerA = imgData.data[centerIndex + 3];

            for (let ky = -Math.floor(kernelSize / 2); ky <= Math.floor(kernelSize / 2); ky++) {
              for (let kx = -Math.floor(kernelSize / 2); kx <= Math.floor(kernelSize / 2); kx++) {
                const nx = x + kx;
                const ny = y + ky;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                  const index = (ny * width + nx) * 4;
                  const r = imgData.data[index];
                  const g = imgData.data[index + 1];
                  const b = imgData.data[index + 2];
                  const a = imgData.data[index + 3];

                  const colorDiff = Math.sqrt(
                    (r - centerR) ** 2 +
                    (g - centerG) ** 2 +
                    (b - centerB) ** 2
                  );
                  const colorWeight = Math.exp(-(colorDiff * colorDiff) / (2 * sigma * sigma));
                  const spatialWeight = spatialKernel[kx + Math.floor(kernelSize / 2)] * spatialKernel[ky + Math.floor(kernelSize / 2)];
                  const weight = colorWeight * spatialWeight;

                  rSum += r * weight;
                  gSum += g * weight;
                  bSum += b * weight;
                  aSum += a * weight;
                  weightSum += weight;
                }
              }
            }

            const index = (y * width + x) * 4;
            outputData[index] = rSum / weightSum;
            outputData[index + 1] = gSum / weightSum;
            outputData[index + 2] = bSum / weightSum;
            outputData[index + 3] = aSum / weightSum;
          }
        }
        imgData.data.set(outputData);
        return imgData;
      }

      function anisotropicFilter(imgData, width, height, strength) {
        if (strength <= 0) return imgData;
        const outputData = new Uint8ClampedArray(imgData.data);
        const iterations = Math.floor(strength);

        for (let iter = 0; iter < iterations; iter++) {
          const tempData = new Uint8ClampedArray(outputData);
          for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
              const index = (y * width + x) * 4;
              let rGradX = 0, rGradY = 0, gGradX = 0, gGradY = 0, bGradX = 0, bGradY = 0;

              for (let c = 0; c < 3; c++) {
                const idx = index + c;
                rGradX += (tempData[idx + 4] - tempData[idx - 4]) * 0.5;
                rGradY += (tempData[idx + width * 4] - tempData[idx - width * 4]) * 0.5;
                gGradX += (tempData[idx + 4 + 1] - tempData[idx - 4 + 1]) * 0.5;
                gGradY += (tempData[idx + width * 4 + 1] - tempData[idx - width * 4 + 1]) * 0.5;
                bGradX += (tempData[idx + 4 + 2] - tempData[idx - 4 + 2]) * 0.5;
                bGradY += (tempData[idx + width * 4 + 2] - tempData[idx - width * 4 + 2]) * 0.5;
              }

              const gradMag = Math.sqrt(rGradX ** 2 + rGradY ** 2 + gGradX ** 2 + gGradY ** 2 + bGradX ** 2 + bGradY ** 2) || 1;
              const diffusion = Math.exp(-gradMag / strength);

              for (let c = 0; c < 4; c++) {
                const idx = index + c;
                const laplacian = (
                  tempData[idx - 4] +
                  tempData[idx + 4] +
                  tempData[idx - width * 4] +
                  tempData[idx + width * 4] -
                  4 * tempData[idx]
                ) * diffusion;
                outputData[idx] = tempData[idx] + 0.25 * laplacian;
              }
            }
          }
        }
        imgData.data.set(outputData);
        return imgData;
      }

      function nonlocalMeansFilter(imgData, width, height, strength) {
        if (strength <= 0) return imgData;
        const outputData = new Uint8ClampedArray(imgData.data);
        const patchSize = 3;
        const searchWindow = 7;
        const h = strength * 10;

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let rSum = 0, gSum = 0, bSum = 0, aSum = 0, weightSum = 0;
            const centerIndex = (y * width + x) * 4;

            for (let ky = -searchWindow; ky <= searchWindow; ky++) {
              for (let kx = -searchWindow; kx <= searchWindow; kx++) {
                const nx = x + kx;
                const ny = y + ky;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                  let patchDiff = 0;
                  for (let py = -patchSize; py <= patchSize; py++) {
                    for (let px = -patchSize; px <= patchSize; px++) {
                      const cx = x + px;
                      const cy = y + py;
                      const nx2 = nx + px;
                      const ny2 = ny + py;
                      if (cx >= 0 && cx < width && cy >= 0 && cy < height && nx2 >= 0 && nx2 < width && ny2 >= 0 && ny2 < height) {
                        const idx1 = (cy * width + cx) * 4;
                        const idx2 = (ny2 * width + nx2) * 4;
                        for (let c = 0; c < 3; c++) {
                          patchDiff += (imgData.data[idx1 + c] - imgData.data[idx2 + c]) ** 2;
                        }
                      }
                    }
                  }
                  const weight = Math.exp(-patchDiff / (h * h));
                  const idx = (ny * width + nx) * 4;
                  rSum += imgData.data[idx] * weight;
                  gSum += imgData.data[idx + 1] * weight;
                  bSum += imgData.data[idx + 2] * weight;
                  aSum += imgData.data[idx + 3] * weight;
                  weightSum += weight;
                }
              }
            }

            const index = (y * width + x) * 4;
            outputData[index] = rSum / weightSum;
            outputData[index + 1] = gSum / weightSum;
            outputData[index + 2] = bSum / weightSum;
            outputData[index + 3] = aSum / weightSum;
          }
        }
        imgData.data.set(outputData);
        return imgData;
      }

      function meanFilter(imgData, width, height, radius) {
        if (radius <= 0) return imgData;
        const kernelSize = radius * 2 + 1;
        const outputData = new Uint8ClampedArray(imgData.data);

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let rSum = 0, gSum = 0, bSum = 0, aSum = 0, count = 0;
            for (let ky = -radius; ky <= radius; ky++) {
              for (let kx = -radius; kx <= radius; kx++) {
                const nx = x + kx;
                const ny = y + ky;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                  const index = (ny * width + nx) * 4;
                  rSum += imgData.data[index];
                  gSum += imgData.data[index + 1];
                  bSum += imgData.data[index + 2];
                  aSum += imgData.data[index + 3];
                  count++;
                }
              }
            }
            const index = (y * width + x) * 4;
            outputData[index] = rSum / count;
            outputData[index + 1] = gSum / count;
            outputData[index + 2] = bSum / count;
            outputData[index + 3] = aSum / count;
          }
        }
        imgData.data.set(outputData);
        return imgData;
      }

      function simplexNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        const perm = new Uint8Array(512);
        for (let i = 0; i < 512; i++) perm[i] = Math.floor(Math.random() * 256);

        function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        function lerp(t, a, b) { return a + t * (b - a); }
        function grad(hash, x, y) {
          const h = hash & 15;
          const u = h < 8 ? x : y;
          const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
          return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              const xi = Math.floor(x / scale);
              const yi = Math.floor(y / scale);
              const xf = (x / scale) - xi;
              const yf = (y / scale) - yi;
              const u = fade(xf);
              const v = fade(yf);

              const aa = perm[(perm[xi + c] + yi) & 255];
              const ab = perm[(perm[xi + c] + yi + 1) & 255];
              const ba = perm[(perm[xi + 1 + c] + yi) & 255];
              const bb = perm[(perm[xi + 1 + c] + yi + 1) & 255];

              const x1 = lerp(u, grad(aa, xf, yf), grad(ba, xf - 1, yf));
              const x2 = lerp(u, grad(ab, xf, yf - 1), grad(bb, xf - 1, yf - 1));
              const value = lerp(v, x1, x2);

              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, ((value + 1) / 2) * intensity * 255));
            }
          }
        }
        return noise;
      }

      function perlinNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              let value = 0;
              let amplitude = 1;
              let frequency = 1 / scale;
              for (let i = 0; i < 8; i++) {
                const sampleX = x * frequency;
                const sampleY = y * frequency;
                value += amplitude * (Math.random() - 0.5) * 2;
                amplitude *= 0.5;
                frequency *= 2;
              }
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, (value * intensity * 255 + 255) / 2));
            }
          }
        }
        return noise;
      }

      function fractalNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              let value = 0;
              let amplitude = 1;
              let frequency = 1 / scale;
              for (let i = 0; i < 6; i++) {
                const sampleX = x * frequency;
                const sampleY = y * frequency;
                value += amplitude * (Math.sin(sampleX) + Math.cos(sampleY));
                amplitude *= 0.5;
                frequency *= 2;
              }
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, (value * intensity * 255 + 255) / 2));
            }
          }
        }
        return noise;
      }

      function cellularNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        const points = [];
        const numPoints = Math.floor(width * height / (scale * scale));
        for (let i = 0; i < numPoints; i++) {
          points.push([Math.random() * width, Math.random() * height]);
        }

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let minDist = Infinity;
            for (const point of points) {
              const dx = x - point[0];
              const dy = y - point[1];
              const dist = Math.sqrt(dx * dx + dy * dy);
              minDist = Math.min(minDist, dist);
            }
            const value = Math.min(1, minDist / scale) * intensity;
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, value * 255));
            }
          }
        }
        return noise;
      }

      function worleyNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        const points = [];
        const numPoints = Math.floor(width * height / (scale * scale));
        for (let i = 0; i < numPoints; i++) {
          points.push([Math.random() * width, Math.random() * height]);
        }

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let distances = [];
            for (const point of points) {
              const dx = x - point[0];
              const dy = y - point[1];
              distances.push(Math.sqrt(dx * dx + dy * dy));
            }
            distances.sort((a, b) => a - b);
            const value = distances[1] / scale * intensity;
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, value * 255));
            }
          }
        }
        return noise;
      }

      function voronoiNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        const points = [];
        const numPoints = Math.floor(width * height / (scale * scale));
        for (let i = 0; i < numPoints; i++) {
          points.push([Math.random() * width, Math.random() * height]);
        }

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let minDist = Infinity;
            let secondMinDist = Infinity;
            for (const point of points) {
              const dx = x - point[0];
              const dy = y - point[1];
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < minDist) {
                secondMinDist = minDist;
                minDist = dist;
              } else if (dist < secondMinDist) {
                secondMinDist = dist;
              }
            }
            const value = (secondMinDist - minDist) / scale * intensity;
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, value * 255));
            }
          }
        }
        return noise;
      }

      function billowNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              let value = 0;
              let amplitude = 1;
              let frequency = 1 / scale;
              for (let i = 0; i < 6; i++) {
                const sampleX = x * frequency;
                const sampleY = y * frequency;
                value += amplitude * Math.abs(Math.sin(sampleX) + Math.cos(sampleY));
                amplitude *= 0.5;
                frequency *= 2;
              }
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, (value * intensity * 255 + 255) / 2));
            }
          }
        }
        return noise;
      }

      function ridgedNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              let value = 0;
              let amplitude = 1;
              let frequency = 1 / scale;
              for (let i = 0; i < 6; i++) {
                const sampleX = x * frequency;
                const sampleY = y * frequency;
                let n = Math.sin(sampleX) + Math.cos(sampleY);
                n = 1 - Math.abs(n);
                n *= n;
                value += amplitude * n;
                amplitude *= 0.5;
                frequency *= 2;
              }
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, (value * intensity * 255 + 255) / 2));
            }
          }
        }
        return noise;
      }

      function whiteNoise(width, height, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.random() * 255 * intensity;
            }
          }
        }
        return noise;
      }

      function pinkNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              let value = 0;
              let amplitude = 1;
              let frequency = 1 / scale;
              for (let i = 0; i < 6; i++) {
                value += amplitude * (Math.random() - 0.5) * 2 / frequency;
                amplitude *= 0.5;
                frequency *= 2;
              }
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, (value * intensity * 255 + 255) / 2));
            }
          }
        }
        return noise;
      }

      function brownNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        let lastValue = [0, 0, 0];
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              lastValue[c] += (Math.random() - 0.5) * 2 / scale;
              lastValue[c] = Math.min(1, Math.max(-1, lastValue[c]));
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, ((lastValue[c] + 1) / 2) * intensity * 255));
            }
          }
        }
        return noise;
      }

      function blueNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              let value = 0;
              let amplitude = 1;
              let frequency = 1 / scale;
              for (let i = 0; i < 6; i++) {
                value += amplitude * (Math.random() - 0.5) * 2 * frequency;
                amplitude *= 0.5;
                frequency *= 2;
              }
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, (value * intensity * 255 + 255) / 2));
            }
          }
        }
        return noise;
      }

      function gradientNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              const nx = x / scale;
              const ny = y / scale;
              const value = (Math.sin(nx) + Math.cos(ny)) * intensity;
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, (value * 255 + 255) / 2));
            }
          }
        }
        return noise;
      }

      function sparkleNoise(width, height, scale, intensity, colorNoise) {
        const noise = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
        const points = [];
        const numPoints = Math.floor(width * height / (scale * scale));
        for (let i = 0; i < numPoints; i++) {
          points.push([Math.random() * width, Math.random() * height]);
        }

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let value = 0;
            for (const point of points) {
              const dx = x - point[0];
              const dy = y - point[1];
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < scale) {
                value += (1 - dist / scale) * intensity;
              }
            }
            for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
              noise[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, value * 255));
            }
          }
        }
        return noise;
      }

      self.onmessage = function(e) {
        try {
          const { width, height, layer, spots, colorPalette } = e.data;
          const { noiseType, noiseLevel, noiseScale, smoothType, smoothValue, colorNoise, alphaLevel } = layer;

          const imgData = new ImageData(width, height);
          const spotArray = [];
          for (let i = 0; i < spots; i++) {
            spotArray.push({
              x: Math.random() * width,
              y: Math.random() * height,
              r: Math.random() * 200 + 100
            });
          }

          let noiseValues;
          if (noiseType === 'perlin') {
            noiseValues = perlinNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'simplex') {
            noiseValues = simplexNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'fractal') {
            noiseValues = fractalNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'cellular') {
            noiseValues = cellularNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'worley') {
            noiseValues = worleyNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'voronoi') {
            noiseValues = voronoiNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'billow') {
            noiseValues = billowNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'ridged') {
            noiseValues = ridgedNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'white') {
            noiseValues = whiteNoise(width, height, noiseLevel, colorNoise);
          } else if (noiseType === 'pink') {
            noiseValues = pinkNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'brown') {
            noiseValues = brownNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'blue') {
            noiseValues = blueNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'saltPepper') {
            noiseValues = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
                  const rand = Math.random();
                  noiseValues[(y * width + x) * (colorNoise ? 3 : 1) + c] = rand < 0.05 * noiseLevel ? 255 : rand > 1 - 0.05 * noiseLevel ? 0 : 128;
                }
              }
            }
          } else if (noiseType === 'gaussian') {
            noiseValues = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
                  const mean = 128;
                  const std = 50 * noiseLevel;
                  const value = mean + std * Math.sqrt(-2 * Math.log(Math.random())) * Math.cos(2 * Math.PI * Math.random());
                  noiseValues[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.min(255, Math.max(0, value));
                }
              }
            }
          } else if (noiseType === 'gradient') {
            noiseValues = gradientNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else if (noiseType === 'sparkle') {
            noiseValues = sparkleNoise(width, height, noiseScale, noiseLevel, colorNoise);
          } else {
            noiseValues = new Uint8ClampedArray(width * height * (colorNoise ? 3 : 1));
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                for (let c = 0; c < (colorNoise ? 3 : 1); c++) {
                  noiseValues[(y * width + x) * (colorNoise ? 3 : 1) + c] = Math.random() * 255 * noiseLevel;
                }
              }
            }
          }

          const paletteRGB = colorPalette ? [
            parseInt(colorPalette.slice(1, 3), 16),
            parseInt(colorPalette.slice(3, 5), 16),
            parseInt(colorPalette.slice(5, 7), 16)
          ] : [255, 255, 255];

          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const index = (y * width + x) * 4;
              let alphaMask = 1;

              for (let spot of spotArray) {
                const dx = x - spot.x;
                const dy = y - spot.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const influence = Math.max(0, 1 - dist / spot.r);
                alphaMask *= (1 - 0.8 * influence);
              }

              const nIndex = (y * width + x) * (colorNoise ? 3 : 1);
              let r = noiseValues[nIndex];
              let g = colorNoise ? noiseValues[nIndex + 1] : r;
              let b = colorNoise ? noiseValues[nIndex + 2] : r;

              r *= paletteRGB[0] / 255;
              g *= paletteRGB[1] / 255;
              b *= paletteRGB[2] / 255;

              const alpha = Math.floor(255 * alphaMask * alphaLevel);

              imgData.data[index] = r;
              imgData.data[index + 1] = g;
              imgData.data[index + 2] = b;
              imgData.data[index + 3] = alpha;
            }
          }

          let processedData = imgData;
          if (smoothType === 'gaussian' && smoothValue > 0) {
            processedData = gaussianBlur(processedData, width, height, smoothValue);
          } else if (smoothType === 'median' && smoothValue > 0) {
            processedData = medianFilter(processedData, width, height, Math.round(smoothValue));
          } else if (smoothType === 'bilateral' && smoothValue > 0) {
            processedData = bilateralFilter(processedData, width, height, smoothValue);
          } else if (smoothType === 'anisotropic' && smoothValue > 0) {
            processedData = anisotropicFilter(processedData, width, height, smoothValue);
          } else if (smoothType === 'nonlocal' && smoothValue > 0) {
            processedData = nonlocalMeansFilter(processedData, width, height, smoothValue);
          } else if (smoothType === 'mean' && smoothValue > 0) {
            processedData = meanFilter(processedData, width, height, Math.round(smoothValue));
          }

          self.postMessage({ imgData: processedData }, [processedData.data.buffer]);
        } catch (error) {
          self.postMessage({ error: error.message });
        }
      };
    `], { type: 'application/javascript' })));

    function resizeCanvas(width, height) {
      canvas.width = Math.max(1, width);
      canvas.height = Math.max(1, height);
    }

    function calculateMetrics(imgData, width, height) {
      const refData = new ImageData(width, height); // –ß–µ—Ä–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∫–∞–∫ —ç—Ç–∞–ª–æ–Ω
      let mse = 0, mae = 0, ssim = 0, entropy = 0;
      let mean1 = 0, mean2 = 0, var1 = 0, var2 = 0, cov = 0;
      const c1 = 0.01 * 255 * 255, c2 = 0.03 * 255 * 255;
      const histogram = new Array(256).fill(0);

      for (let i = 0; i < width * height * 4; i += 4) {
        const v1 = (imgData.data[i] + imgData.data[i + 1] + imgData.data[i + 2]) / 3;
        const v2 = (refData.data[i] + refData.data[i + 1] + refData.data[i + 2]) / 3;
        const diff = v1 - v2;
        mse += diff * diff;
        mae += Math.abs(diff);
        mean1 += v1;
        mean2 += v2;
        histogram[Math.floor(v1)]++;
      }

      mse /= (width * height);
      mae /= (width * height);
      mean1 /= (width * height);
      mean2 /= (width * height);

      for (let i = 0; i < width * height * 4; i += 4) {
        const v1 = (imgData.data[i] + imgData.data[i + 1] + imgData.data[i + 2]) / 3;
        const v2 = (refData.data[i] + refData.data[i + 1] + refData.data[i + 2]) / 3;
        var1 += (v1 - mean1) ** 2;
        var2 += (v2 - mean2) ** 2;
        cov += (v1 - mean1) * (v2 - mean2);
      }

      var1 /= (width * height);
      var2 /= (width * height);
      cov /= (width * height);

      ssim = ((2 * mean1 * mean2 + c1) * (2 * cov + c2)) / ((mean1 ** 2 + mean2 ** 2 + c1) * (var1 + var2 + c2));
      const psnr = 10 * Math.log10((255 * 255) / (mse || 1));
      const rmse = Math.sqrt(mse);

      // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —ç–Ω—Ç—Ä–æ–ø–∏–∏
      const totalPixels = width * height;
      for (let i = 0; i < 256; i++) {
        if (histogram[i] > 0) {
          const p = histogram[i] / totalPixels;
          entropy -= p * Math.log2(p);
        }
      }

      return { ssim: ssim * 100, psnr, rmse, mae, entropy };
    }

    function updateRecommendations(metrics, generationTime) {
      const recs = [];
      if (metrics.ssim > 90) {
        recs.push("–£–≤–µ–ª–∏—á—å—Ç–µ –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —à—É–º–∞ –¥–ª—è –±–æ–ª—å—à–µ–π –≤–∞—Ä–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç–∏.");
      } else if (metrics.rmse < 10) {
        recs.push("–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —É–º–µ–Ω—å—à–∏—Ç—å –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å –∏–ª–∏ –¥–æ–±–∞–≤–∏—Ç—å —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ.");
      }
      if (metrics.entropy < 6) {
        recs.push("–î–æ–±–∞–≤—å—Ç–µ –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–µ —Ç–∏–ø—ã —à—É–º–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –§—Ä–∞–∫—Ç–∞–ª) –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏ –∏–ª–∏ —É—Å–∏–ª—å—Ç–µ –≤–ª–∏—è–Ω–∏–µ —Å–ª–æ—è.");
      }
      if (layers.length > 3) {
        recs.push("–ú–Ω–æ–≥–æ —Å–ª–æ–µ–≤ –º–æ–∂–µ—Ç –∑–∞–º–µ–¥–ª–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ–±—ä–µ–¥–∏–Ω–∏—Ç—å —Å–ª–æ–∏ —Å –Ω–∏–∑–∫–∏–º –≤–µ—Å–æ–º.");
      }
      recommendationsDiv.textContent = recs.length ? `–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏: ${recs.join(' ')}` : '–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã.';
    }

    function addLayer() {
      const newLayer = {
        id: Date.now(),
        noiseType: 'random',
        weight: 0.5,
        noiseLevel: 0.7,
        noiseScale: 10,
        smoothType: 'gaussian',
        smoothValue: 0,
        spots: 10,
        colorNoise: false,
        alphaLevel: 1
      };
      layers.push(newLayer);
      updateLayerUI();
      saveToHistory();
      generateNoise();
    }

    function removeLayer(id) {
      layers = layers.filter(layer => layer.id !== id);
      updateLayerUI();
      generateNoise();
      saveToHistory();
    }

    function updateSmoothInputAttributes(layerId, smoothType) {
      const input = document.querySelector(`#smoothValue-${layerId}`);
      const tooltip = input.parentElement.querySelector('.tooltip');
      if (smoothType === 'gaussian') {
        input.min = 0;
        input.max = 10;
        input.step = 0.1;
        tooltip.textContent = '–†–∞–¥–∏—É—Å –≥–∞—É—Å—Å–æ–≤–∞ —Ä–∞–∑–º—ã—Ç–∏—è (0‚Äì10)';
      } else if (smoothType === 'median') {
        input.min = 0;
        input.max = 5;
        input.step = 1;
        tooltip.textContent = '–†–∞–¥–∏—É—Å –º–µ–¥–∏–∞–Ω–Ω–æ–≥–æ —Ñ–∏–ª—å—Ç—Ä–∞ (0‚Äì5)';
      } else if (smoothType === 'bilateral') {
        input.min = 0;
        input.max = 5;
        input.step = 0.1;
        tooltip.textContent = '–°–∏–≥–º–∞ –±–∏–ª–∞—Ç–µ—Ä–∞–ª—å–Ω–æ–≥–æ —Ñ–∏–ª—å—Ç—Ä–∞ (0‚Äì5)';
      } else if (smoothType === 'anisotropic') {
        input.min = 0;
        input.max = 10;
        input.step = 0.1;
        tooltip.textContent = '–°–∏–ª–∞ –∞–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–æ–≥–æ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è (0‚Äì10)';
      } else if (smoothType === 'nonlocal') {
        input.min = 0;
        input.max = 5;
        input.step = 0.1;
        tooltip.textContent = '–°–∏–ª–∞ –Ω–µ–ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è (0‚Äì5)';
      } else if (smoothType === 'mean') {
        input.min = 0;
        input.max = 5;
        input.step = 1;
        tooltip.textContent = '–†–∞–¥–∏—É—Å —É—Å—Ä–µ–¥–Ω—è—é—â–µ–≥–æ —Ñ–∏–ª—å—Ç—Ä–∞ (0‚Äì5)';
      }
    }

    function updateLayerUI() {
      const layerList = document.getElementById('layerList');
      layerList.innerHTML = '';
      layers.forEach(layer => {
        const div = document.createElement('div');
        div.className = 'layer-item';
        div.innerHTML = `
          <div class="control-group">
            <label>–¢–∏–ø —à—É–º–∞</label>
            <select onchange="updateLayer(${layer.id}, 'noiseType', this.value)">
              <option value="random" ${layer.noiseType === 'random' ? 'selected' : ''}>–°–ª—É—á–∞–π–Ω—ã–π</option>
              <option value="perlin" ${layer.noiseType === 'perlin' ? 'selected' : ''}>–ü–µ—Ä–ª–∏–Ω–æ–≤—ã–π</option>
              <option value="simplex" ${layer.noiseType === 'simplex' ? 'selected' : ''}>–°–∏–º–ø–ª–µ–∫—Å–∞</option>
              <option value="fractal" ${layer.noiseType === 'fractal' ? 'selected' : ''}>–§—Ä–∞–∫—Ç–∞–ª—å–Ω—ã–π</option>
              <option value="cellular" ${layer.noiseType === 'cellular' ? 'selected' : ''}>–ö–ª–µ—Ç–æ—á–Ω—ã–π</option>
              <option value="voronoi" ${layer.noiseType === 'voronoi' ? 'selected' : ''}>–í–æ—Ä–æ–Ω–æ–π</option>
              <option value="billow" ${layer.noiseType === 'billow' ? 'selected' : ''}>–ë–∏–ª–ª–æ—É</option>
              <option value="ridged" ${layer.noiseType === 'ridged' ? 'selected' : ''}>–†–∏–¥–∂–µ–¥</option>
              <option value="white" ${layer.noiseType === 'white' ? 'selected' : ''}>–ë–µ–ª—ã–π</option>
              <option value="pink" ${layer.noiseType === 'pink' ? 'selected' : ''}>–†–æ–∑–æ–≤—ã–π</option>
              <option value="brown" ${layer.noiseType === 'brown' ? 'selected' : ''}>–ö–æ—Ä–∏—á–Ω–µ–≤—ã–π</option>
              <option value="blue" ${layer.noiseType === 'blue' ? 'selected' : ''}>–°–∏–Ω–∏–π</option>
              <option value="saltPepper" ${layer.noiseType === 'saltPepper' ? 'selected' : ''}>–°–æ–ª—å-–ø–µ—Ä–µ—Ü</option>
              <option value="gaussian" ${layer.noiseType === 'gaussian' ? 'selected' : ''}>–ì–∞—É—Å—Å–æ–≤</option>
              <option value="gradient" ${layer.noiseType === 'gradient' ? 'selected' : ''}>–ì—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π</option>
              <option value="sparkle" ${layer.noiseType === 'sparkle' ? 'selected' : ''}>–ò—Å–∫—Ä—ã</option>
            </select>
            <span class="tooltip">–¢–∏–ø —à—É–º–∞ –¥–ª—è —Å–ª–æ—è</span>
          </div>
          <div class="control-group">
            <label>–í–ª–∏—è–Ω–∏–µ —Å–ª–æ—è</label>
            <input type="number" value="${layer.weight}" min="0" max="1" step="0.01" onchange="updateLayer(${layer.id}, 'weight', this.value)" />
            <span class="tooltip">–í–ª–∏—è–Ω–∏–µ —Å–ª–æ—è –Ω–∞ –∏—Ç–æ–≥–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (0‚Äì1)</span>
          </div>
          <div class="control-group">
            <label>–ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å</label>
            <input type="number" value="${layer.noiseLevel}" min="0" max="1" step="0.01" onchange="updateLayer(${layer.id}, 'noiseLevel', this.value)" />
            <span class="tooltip">–û–±—â–∞—è –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —à—É–º–∞ —Å–ª–æ—è</span>
          </div>
          <div class="control-group">
            <label>–ú–∞—Å—à—Ç–∞–± —à—É–º–∞</label>
            <input type="number" value="${layer.noiseScale}" min="1" max="100" step="1" onchange="updateLayer(${layer.id}, 'noiseScale', this.value)" />
            <span class="tooltip">–†–∞–∑–º–µ—Ä –¥–µ—Ç–∞–ª–µ–π —à—É–º–∞</span>
          </div>
          <div class="control-group">
            <label>–¢–∏–ø —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è</label>
            <select onchange="updateLayer(${layer.id}, 'smoothType', this.value); updateSmoothInputAttributes(${layer.id}, this.value)">
              <option value="gaussian" ${layer.smoothType === 'gaussian' ? 'selected' : ''}>–ì–∞—É—Å—Å–æ–≤–æ</option>
              <option value="median" ${layer.smoothType === 'median' ? 'selected' : ''}>–ú–µ–¥–∏–∞–Ω–Ω–æ–µ</option>
              <option value="bilateral" ${layer.smoothType === 'bilateral' ? 'selected' : ''}>–ë–∏–ª–∞—Ç–µ—Ä–∞–ª—å–Ω–æ–µ</option>
              <option value="anisotropic" ${layer.smoothType === 'anisotropic' ? 'selected' : ''}>–ê–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–æ–µ</option>
              <option value="nonlocal" ${layer.smoothType === 'nonlocal' ? 'selected' : ''}>–ù–µ–ª–æ–∫–∞–ª—å–Ω–æ–µ</option>
              <option value="mean" ${layer.smoothType === 'mean' ? 'selected' : ''}>–£—Å—Ä–µ–¥–Ω—è—é—â–µ–µ</option>
            </select>
            <span class="tooltip">–¢–∏–ø —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è –¥–ª—è —Å–ª–æ—è</span>
          </div>
          <div class="control-group">
            <label>–°–∏–ª–∞ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è</label>
            <input id="smoothValue-${layer.id}" type="number" value="${layer.smoothValue}" onchange="updateLayer(${layer.id}, 'smoothValue', this.value)" />
            <span class="tooltip">–†–∞–¥–∏—É—Å –∏–ª–∏ —Å–∏–ª–∞ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è</span>
          </div>
          <div class="control-group">
            <label>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—è—Ç–µ–Ω</label>
            <input type="number" value="${layer.spots}" min="0" max="100" step="1" onchange="updateLayer(${layer.id}, 'spots', this.value)" />
            <span class="tooltip">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—è—Ç–µ–Ω –¥–ª—è –º–∞—Å–∫–∏</span>
          </div>
          <div class="control-group">
            <label>–¶–≤–µ—Ç–Ω–æ–π —à—É–º</label>
            <input type="checkbox" ${layer.colorNoise ? 'checked' : ''} onchange="updateLayer(${layer.id}, 'colorNoise', this.checked)" />
            <span class="tooltip">–í–∫–ª—é—á–∏—Ç—å RGB-—à—É–º</span>
          </div>
          <div class="control-group">
            <label>–ê–ª—å—Ñ–∞-–∫–∞–Ω–∞–ª</label>
            <input type="number" value="${layer.alphaLevel}" min="0" max="1" step="0.01" onchange="updateLayer(${layer.id}, 'alphaLevel', this.value)" />
            <span class="tooltip">–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å —Å–ª–æ—è (0‚Äì1)</span>
          </div>
          <div class="control-group">
            <label>–£–¥–∞–ª–∏—Ç—å —Å–ª–æ–π</label>
            <button onclick="removeLayer(${layer.id})">–£–¥–∞–ª–∏—Ç—å</button>
            <span class="tooltip">–£–¥–∞–ª—è–µ—Ç —Å–ª–æ–π</span>
          </div>
        `;
        layerList.appendChild(div);
        updateSmoothInputAttributes(layer.id, layer.smoothType);
      });
    }

    function updateLayer(id, key, value) {
      const layer = layers.find(l => l.id === id);
      if (layer) {
        layer[key] = key === 'colorNoise' ? value : key === 'smoothType' ? value : +value || value;
        generateNoise();
        saveToHistory();
      }
    }

    function saveToHistory() {
      history = history.slice(0, historyIndex + 1);
      history.push({
        layers: JSON.parse(JSON.stringify(layers)),
        canvasData: ctx.getImageData(0, 0, canvas.width, canvas.height)
      });
      historyIndex++;
      if (history.length > 50) {
        history.shift();
        historyIndex--;
      }
    }

    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        const state = history[historyIndex];
        layers = JSON.parse(JSON.stringify(state.layers));
        ctx.putImageData(state.canvasData, 0, 0);
        updateLayerUI();
      }
    }

    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        const state = history[historyIndex];
        layers = JSON.parse(JSON.stringify(state.layers));
        ctx.putImageData(state.canvasData, 0, 0);
        updateLayerUI();
      }
    }

    async function generateNoise(preview = false) {
      try {
        const startTime = performance.now();
        const widthInput = +document.getElementById('width').value;
        const heightInput = +document.getElementById('height').value;
        const width = preview ? Math.min(widthInput, 256) : widthInput;
        const height = preview ? Math.min(heightInput, 256) : heightInput;
        resizeCanvas(width, height);
        const colorPalette = document.getElementById('colorPalette').value;

        progress.style.display = 'block';
        progress.textContent = '–û–±—Ä–∞–±–æ—Ç–∫–∞: 0%';
        ctx.clearRect(0, 0, width, height);

        const finalImageData = ctx.createImageData(width, height);
        const chunkSize = Math.ceil(height / 10);

        for (let layer of layers) {
          const chunkImageData = await new Promise((resolve, reject) => {
            noiseWorker.onmessage = function (e) {
              if (e.data.error) {
                reject(new Error(e.data.error));
              } else {
                resolve(e.data.imgData);
              }
            };
            noiseWorker.onerror = function (e) {
              reject(new Error('–û—à–∏–±–∫–∞ –≤ Web Worker: ' + e.message));
            };
            noiseWorker.postMessage({
              width,
              height,
              layer,
              spots: layer.spots || 10,
              colorPalette
            });
          });

          for (let i = 0; i < finalImageData.data.length; i += 4) {
            finalImageData.data[i] += chunkImageData.data[i] * (layer.weight || 0.5);
            finalImageData.data[i + 1] += chunkImageData.data[i + 1] * (layer.weight || 0.5);
            finalImageData.data[i + 2] += chunkImageData.data[i + 2] * (layer.weight || 0.5);
            finalImageData.data[i + 3] += chunkImageData.data[i + 3] * (layer.weight || 0.5);
          }

          for (let y = 0; y < height; y += chunkSize) {
            const chunkHeight = Math.min(chunkSize, height - y);
            const chunkData = ctx.createImageData(width, chunkHeight);
            for (let cy = 0; cy < chunkHeight; cy++) {
              for (let x = 0; x < width; x++) {
                const srcIndex = ((y + cy) * width + x) * 4;
                const dstIndex = (cy * width + x) * 4;
                chunkData.data[dstIndex] = finalImageData.data[srcIndex];
                chunkData.data[dstIndex + 1] = finalImageData.data[srcIndex + 1];
                chunkData.data[dstIndex + 2] = finalImageData.data[srcIndex + 2];
                chunkData.data[dstIndex + 3] = finalImageData.data[srcIndex + 3];
              }
            }
            ctx.putImageData(chunkData, 0, y);
            progress.textContent = `–û–±—Ä–∞–±–æ—Ç–∫–∞: ${Math.round((y + chunkHeight) / height * 100)}%`;
            await new Promise(resolve => requestAnimationFrame(resolve));
          }
        }

        ctx.putImageData(finalImageData, 0, 0);
        progress.style.display = 'none';


        const endTime = performance.now();
        const generationTime = (endTime - startTime).toFixed(2);

        const metrics = calculateMetrics(finalImageData, width, height);
        metricsDiv.textContent = `SSIM: ${metrics.ssim.toFixed(2)}%, PSNR: ${metrics.psnr.toFixed(2)} dB, RMSE: ${metrics.rmse.toFixed(2)}, MAE: ${metrics.mae.toFixed(2)}, Entropy: ${metrics.entropy.toFixed(2)}, –í—Ä–µ–º—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: ${generationTime} –º—Å`;
        updateRecommendations(metrics, generationTime);

        saveToHistory();
      } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:', error);
        progress.textContent = '–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏';
        progress.style.display = 'block';
      }
    }

    async function previewNoise() {
      await generateNoise(true);
    }

    function download(name = 'noise.png') {
      const link = document.createElement('a');
      link.download = name;
      link.href = canvas.toDataURL();
      link.click();
    }

    async function saveCopies() {
      const count = +copiesInput.value || 5;
      progress.style.display = 'block';
      for (let i = 0; i < count; i++) {
        await generateNoise();
        progress.textContent = `–û–±—Ä–∞–±–æ—Ç–∫–∞: ${Math.round((i + 1) / count * 100)}%`;
        await new Promise(resolve => setTimeout(resolve, 100));
        download(`noise${i + 1}.png`);
      }
      progress.style.display = 'none';
    }

    function saveSettings() {
      const settings = {
        width: document.getElementById('width').value,
        height: document.getElementById('height').value,
        layers,
        colorPalette: document.getElementById('colorPalette').value,
        copies: copiesInput.value
      };
      const presetName = prompt('–í–≤–µ–¥–∏—Ç–µ –∏–º—è –ø—Ä–µ—Å–µ—Ç–∞:') || 'default';
      let presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      presets[presetName] = settings;
      localStorage.setItem('noisePresets', JSON.stringify(presets));
      alert('–ü—Ä–µ—Å–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω!');
    }

    function loadPresets() {
      const presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      const presetName = prompt('–í–≤–µ–¥–∏—Ç–µ –∏–º—è –ø—Ä–µ—Å–µ—Ç–∞ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏:\n–î–æ—Å—Ç—É–ø–Ω—ã–µ: ' + Object.keys(presets).join(', '));
      if (presets[presetName]) {
        const settings = presets[presetName];
        document.getElementById('width').value = settings.width || 512;
        document.getElementById('height').value = settings.height || 1024;
        document.getElementById('colorPalette').value = settings.colorPalette || '#ffffff';
        layers = settings.layers || [{
          id: Date.now(),
          noiseType: 'random',
          weight: 0.5,
          noiseLevel: 0.7,
          noiseScale: 10,
          smoothType: 'gaussian',
          smoothValue: 0,
          spots: 10,
          colorNoise: false,
          alphaLevel: 1
        }];
        copiesInput.value = settings.copies || 5;
        copiesDisplay.textContent = settings.copies || 5;
        updateLayerUI();
        generateNoise();
      } else {
        alert('–ü—Ä–µ—Å–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω!');
      }
    }

    copiesInput.addEventListener('input', () => {
      copiesDisplay.textContent = copiesInput.value;
    });

    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    const inputs = document.querySelectorAll('input, select');
    inputs.forEach(input => {
      input.addEventListener('input', debounce(generateNoise, 300));
    });

    window.addEventListener('resize', generateNoise);
    updateLayerUI();
    generateNoise();


    function openPresetModal() {
      document.getElementById("presetModal").style.display = "block";
      updatePresetList();
    }

    function closePresetModal() {
      document.getElementById("presetModal").style.display = "none";
    }

    document.getElementById("savePresetButton").addEventListener("click", function () {
      const nameInput = document.getElementById("presetNameInput");
      const presetName = nameInput.value.trim();
      if (!presetName) return;

      const settings = {
        width: document.getElementById('width').value,
        height: document.getElementById('height').value,
        layers,
        colorPalette: document.getElementById('colorPalette').value,
        copies: copiesInput.value
      };

      let presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      presets[presetName] = settings;
      localStorage.setItem('noisePresets', JSON.stringify(presets));

      nameInput.value = '';
      updatePresetList();
    });

    function loadPreset(presetName) {
      const presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      const settings = presets[presetName];
      if (!settings) return;

      document.getElementById('width').value = settings.width || 512;
      document.getElementById('height').value = settings.height || 1024;
      document.getElementById('colorPalette').value = settings.colorPalette || '#ffffff';
      layers = settings.layers || getDefaultLayers();
      copiesInput.value = settings.copies || 5;
      copiesDisplay.textContent = settings.copies || 5;

      updateLayerUI();
      generateNoise();
      closePresetModal();
    }

    function deletePreset(presetName) {
      if (!confirm(`–£–¥–∞–ª–∏—Ç—å –ø—Ä–µ—Å–µ—Ç "${presetName}"? –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ.`)) return;
      let presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      delete presets[presetName];
      localStorage.setItem('noisePresets', JSON.stringify(presets));
      updatePresetList();
    }

    function updatePresetList() {
      const listContainer = document.getElementById("presetList");
      listContainer.innerHTML = "";

      const presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      const sortedNames = Object.keys(presets).sort();

      sortedNames.forEach(name => {
        const card = document.createElement("div");
        card.className = "preset-card";

        const title = document.createElement("div");
        title.textContent = name;

        const loadBtn = document.createElement("button");
        loadBtn.textContent = "–ó–∞–≥—Ä—É–∑–∏—Ç—å";
        loadBtn.className = "load";
        loadBtn.onclick = () => loadPreset(name);

        const deleteBtn = document.createElement("button");
        deleteBtn.textContent = "–£–¥–∞–ª–∏—Ç—å";
        deleteBtn.className = "delete";
        deleteBtn.onclick = () => deletePreset(name);

        card.appendChild(title);
        card.appendChild(loadBtn);
        card.appendChild(deleteBtn);
        listContainer.appendChild(card);
      });
    }

    document.getElementById("closeModal").addEventListener("click", closePresetModal);
    document.getElementById("openPresetModalButton").addEventListener("click", openPresetModal);
    window.onclick = function (event) {
      if (event.target == document.getElementById("presetModal")) closePresetModal();
    };

    function getDefaultLayers() {
      return [{
        id: Date.now(),
        noiseType: 'random',
        weight: 0.5,
        noiseLevel: 0.7,
        noiseScale: 10,
        smoothType: 'gaussian',
        smoothValue: 0,
        spots: 10,
        colorNoise: false,
        alphaLevel: 1
      }];
    }

  </script>
</body>

</html>
