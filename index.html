<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —à—É–º–∞</title>
  <style>
    :root {
      --bg-color: #222;
      --card-bg: #333;
      --text-color: #ffffff;
      --accent-color: #1465ac;
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      --border-radius: 12px;
    }

    body {
      background: var(--bg-color);
      color: var(--text-color);
      font-family: -apple-system, BlinkMacSystemFont, 'system-ui', sans-serif;
      margin: 0;
      padding: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      overflow-y: auto;
      box-sizing: border-box;
    }

    .container {
      max-width: 1200px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 16px;
      max-height: 100vh;
      box-sizing: border-box;
    }

    .canvas-container {
      position: relative;
      width: 100%;
      display: flex;
      justify-content: center;
    }

    canvas {
      border: 1px solid #555;
      border-radius: var(--border-radius);
      max-height: calc(100vh - 320px);
      width: 100%;
      object-fit: contain;
      background: #000;
      box-shadow: var(--shadow);
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      padding: 12px;
      background: var(--card-bg);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
      position: relative;
    }

    label {
      font-size: 14px;
      font-weight: 500;
      opacity: 0.9;
    }

    input[type="number"],
    select,
    input[type="checkbox"],
    input[type="color"] {
      background: #666;
      border: none;
      border-radius: 8px;
      padding: 8px;
      color: var(--text-color);
      font-size: 14px;
      transition: background 0.2s;
      width: 100%;
      box-sizing: border-box;
    }

    input[type="number"]:hover,
    select:hover,
    input[type="color"]:hover {
      background: #4a545c;
    }

    button {
      background: var(--accent-color);
      border: none;
      border-radius: 7px;
      padding: 10px 16px;
      color: white;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: transform 0.1s, background 0.2s;
      box-shadow: var(--shadow);
    }

    button:hover {
      background: #082f51;
      transform: scale(1.04);
    }

    button:active {
      transform: scale(0.95);
    }

    .actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
      padding: 12px;
      background: var(--card-bg);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
    }

    .layers {
      padding: 12px;
      background: var(--card-bg);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
    }

    .layer-item {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      padding: 8px;
      border-bottom: 1px solid #555;
    }

    #progress,
    #metrics,
    #recommendations {
      font-size: 14px;
      padding: 12px;
      background: var(--card-bg);
      border-radius: var(--border-radius);
      text-align: center;
      box-shadow: var(--shadow);
    }

    #progress {
      display: none;
      background-color: #D12525;
    }

    #metrics,
    #recommendations {
      display: block;
      font-size: 13px;
      opacity: 0.9;
    }

    #recommendations {
      text-align: left;
    }

    .tooltip {
      visibility: hidden;
      background: #000;
      color: white;
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 6px;
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      white-space: nowrap;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .control-group:hover .tooltip {
      visibility: visible;
      opacity: 1;
    }

    @media (max-width: 600px) {

      .controls,
      .layer-item {
        grid-template-columns: 1fr;
      }

      canvas {
        max-height: calc(100vh - 400px);
      }
    }

    /* –°—Ç–∏–ª–∏ –¥–ª—è –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
    }

    .modal-content {
      background-color: #2e2e2e;
      margin: 5% auto;
      padding: 15px;
      border-radius: 12px;
      width: 80%;
      max-width: 1900px;
      color: white;
      font-family: sans-serif;
      box-shadow: 0 0 15px black;
      animation: fadeIn 0.3s ease-out;
    }

    .close {
      float: right;
      font-size: 28px;
      cursor: pointer;
    }

    .preset-list {
      padding: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 2px;
      max-height: 400px;
      overflow-y: auto;
      padding-right: 10px;
    }

    /* –°—Ç–∏–ª–∏–∑–∞—Ü–∏—è —Å–∫—Ä–æ–ª–ª–±–∞—Ä–∞ */
    #presetList::-webkit-scrollbar {
      width: 8px;
      /* –®–∏—Ä–∏–Ω–∞ —Å–∫—Ä–æ–ª–ª–±–∞—Ä–∞ */
    }

    #presetList::-webkit-scrollbar-thumb {
      background-color: #1465ac;
      /* –¶–≤–µ—Ç –±–µ–≥—É–Ω–∫–∞ */
      border-radius: 2px;
      /* –ó–∞–∫—Ä—É–≥–ª–µ–Ω–∏–µ —É–≥–ª–æ–≤ */
      border: 2px solid #fff;
    }

    #presetList::-webkit-scrollbar-track {
      background-color: #f1f1f1;
      border-radius: 4px;
    }

    /* –î–ª—è Firefox */
    #presetList {
      scrollbar-width: thin;
      scrollbar-color: #1465ac #0e0e0e;
    }

    .preset-card {
      background: #444;
      border-radius: 8px;
      padding: 10px;
      width: 150px;
      text-align: center;
      box-shadow: 0 0 5px black;
    }

    .preset-card button {
      margin-top: 5px;
      width: 100%;
      padding: 4px;
      border: none;
      cursor: pointer;
    }

    .preset-card button.load {
      background-color: #39ba7b;
      color: white;
    }

    .preset-card button.delete {
      background-color: #c34034;
      color: white;

    }

    #presetNameInput {
      padding: 10px;
      border-radius: 5px;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  </style>
</head>

<body>
  <!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ -->
  <div id="presetModal" class="modal">
    <div class="modal-content">
      <span id="closeModal" class="close">&times;</span>

      <h2>üéõ –ú–µ–Ω—é –ø—Ä–µ—Å–µ—Ç–æ–≤</h2>

      <div class="save-section">
        <h3>üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–æ–≤—ã–π –ø—Ä–µ—Å–µ—Ç</h3>
        <input type="text" id="presetNameInput" placeholder="–ò–º—è –ø—Ä–µ—Å–µ—Ç–∞" />
        <button id="savePresetButton">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
      </div>

      <div class="load-section">
        <h3>üìö –ó–∞–≥—Ä—É–∑–∏—Ç—å/ üóëÔ∏è –£–¥–∞–ª–∏—Ç—å –ø—Ä–µ—Å–µ—Ç</h3>
        <button id="defaultPreset" onclick="initializePresets()">–í–µ—Ä–Ω—É—Ç—å –±–∞–∑–æ–≤—ã–µ –ø—Ä–µ—Å–µ—Ç—ã</button>

        <div id="presetList" class="preset-list"></div>
      </div>
    </div>

  </div>

  <div class="container">

    <button id="openPresetModalButton">–ú–µ–Ω—é –ø—Ä–µ—Å–µ—Ç–æ–≤</button>
    <div id="metrics">SSIM: -, PSNR: -, RMSE: -, MAE: -, Entropy: -</div>

    <div class="layers">
      <button onclick="addLayer()">‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å–ª–æ–π</button>
      <div id="layerList"></div>
    </div>

    <div id="progress">–û–±—Ä–∞–±–æ—Ç–∫–∞: 0%</div>

    <div class="canvas-container">
      <canvas id="noiseCanvas"></canvas>
    </div>

    <div id="recommendations">–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏: -</div>

    <div class="actions">
      <button onclick="generateNoise()">üé≤ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å</button>
      <button onclick="download()">üíæ –°–∫–∞—á–∞—Ç—å</button>
      <button onclick="saveCopies()">üìÅ –°–∫–∞—á–∞—Ç—å <span id="copiesDisplay">5</span> –∫–æ–ø–∏–π:</button>
      <input type="number" id="copies" value="5" min="1" style="width: 60px;" />
      <button onclick="undo()">‚Ü©Ô∏è –û—Ç–º–µ–Ω–∏—Ç—å</button>
      <button onclick="redo()">‚Ü™Ô∏è –í–µ—Ä–Ω—É—Ç—å</button>
    </div>

    <div class="controls">
      <div class="control-group">
        <label>–®–∏—Ä–∏–Ω–∞</label>
        <input type="number" id="width" value="512" min="1" />
        <span class="tooltip">–®–∏—Ä–∏–Ω–∞ —à—É–º–∞ –≤ –ø–∏–∫—Å–µ–ª—è—Ö</span>
      </div>
      <div class="control-group">
        <label>–í—ã—Å–æ—Ç–∞</label>
        <input type="number" id="height" value="1024" min="1" />
        <span class="tooltip">–í—ã—Å–æ—Ç–∞ —à—É–º–∞ –≤ –ø–∏–∫—Å–µ–ª—è—Ö</span>
      </div>
      <div class="control-group">
        <label>–¶–≤–µ—Ç —à—É–º–∞</label>
        <input type="color" id="colorPalette" value="#ffffff" />
        <span class="tooltip">–û—Å–Ω–æ–≤–Ω–æ–π —Ü–≤–µ—Ç –¥–ª—è —Ü–≤–µ—Ç–Ω–æ–≥–æ —à—É–º–∞</span>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('noiseCanvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const progress = document.getElementById('progress');
    const metricsDiv = document.getElementById('metrics');
    const recommendationsDiv = document.getElementById('recommendations');
    const copiesInput = document.getElementById('copies');
    const copiesDisplay = document.getElementById('copiesDisplay');
    let history = [];
    let historyIndex = -1;
    let layers = [{
      id: Date.now(),
      noiseType: 'perlin',
      weight: 0.7,
      noiseLevel: 0.7,
      noiseScale: 50,
      smoothType: 'gaussian',
      smoothValue: 0,
      spots: 2,
      colorNoise: false,
      alphaLevel: 1
    }];

    // Web Worker
    const noiseWorker = new Worker('worker.js'); // –ü–æ–¥–∫–ª—é—á–∞–µ–º –≤–Ω–µ—à–Ω–∏–π Worker

    function resizeCanvas(width, height) {
      canvas.width = Math.max(1, width);
      canvas.height = Math.max(1, height);
    }

    function calculateMetrics(imgData, width, height) {
      const refData = new ImageData(width, height); // –ß–µ—Ä–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∫–∞–∫ —ç—Ç–∞–ª–æ–Ω
      let mse = 0, mae = 0, ssim = 0, entropy = 0, ae = 0, ncc = 0;
      let mean1 = 0, mean2 = 0, var1 = 0, var2 = 0, cov = 0;
      const c1 = 0.01 * 255 * 255, c2 = 0.03 * 255 * 255;
      const histogram = new Array(256).fill(0);
      let sumDiff = 0, sum1 = 0, sum2 = 0, sum1squared = 0, sum2squared = 0, sumProduct = 0;

      for (let i = 0; i < width * height * 4; i += 4) {
        const v1 = (imgData.data[i] + imgData.data[i + 1] + imgData.data[i + 2]) / 3;
        const v2 = (refData.data[i] + refData.data[i + 1] + refData.data[i + 2]) / 3;
        const diff = v1 - v2;
        mse += diff * diff;
        mae += Math.abs(diff);
        sumDiff += diff; // –î–ª—è AE
        mean1 += v1;
        mean2 += v2;
        sum1 += v1;
        sum2 += v2;
        sum1squared += v1 * v1;
        sum2squared += v2 * v2;
        sumProduct += v1 * v2;
        histogram[Math.floor(v1)]++;
      }

      const totalPixels = width * height;
      mse /= totalPixels;
      mae /= totalPixels;
      mean1 /= totalPixels;
      mean2 /= totalPixels;
      ae = sumDiff / totalPixels; // –°—Ä–µ–¥–Ω—è—è –æ—à–∏–±–∫–∞ (AE)

      // NCC = Œ£((x - Œºx)(y - Œºy)) / sqrt(Œ£(x - Œºx)¬≤ * Œ£(y - Œºy)¬≤)
      ncc = (sumProduct - sum1 * sum2 / totalPixels) /
        Math.sqrt((sum1squared - sum1 * sum1 / totalPixels) * (sum2squared - sum2 * sum2 / totalPixels)) || 0;

      for (let i = 0; i < width * height * 4; i += 4) {
        const v1 = (imgData.data[i] + imgData.data[i + 1] + imgData.data[i + 2]) / 3;
        const v2 = (refData.data[i] + refData.data[i + 1] + refData.data[i + 2]) / 3;
        var1 += (v1 - mean1) ** 2;
        var2 += (v2 - mean2) ** 2;
        cov += (v1 - mean1) * (v2 - mean2);
      }

      var1 /= totalPixels;
      var2 /= totalPixels;
      cov /= totalPixels;

      ssim = ((2 * mean1 * mean2 + c1) * (2 * cov + c2)) / ((mean1 ** 2 + mean2 ** 2 + c1) * (var1 + var2 + c2));
      const psnr = 10 * Math.log10((255 * 255) / (mse || 1));
      const rmse = Math.sqrt(mse);

      for (let i = 0; i < 256; i++) {
        if (histogram[i] > 0) {
          const p = histogram[i] / totalPixels;
          entropy -= p * Math.log2(p);
        }
      }

      return { ssim: ssim * 100, psnr, rmse, mae, entropy, ae, ncc: ncc * 100 };
    }

    function updateRecommendations(metrics, generationTime) {
      const recs = [];

      // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ SSIM (Structural Similarity Index)
      if (metrics.ssim > 70) {
        recs.push("–°—Ö–æ–∂–µ—Å—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –≤—ã—Å–æ–∫–∞ (SSIM > 70%). –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —É–≤–µ–ª–∏—á–∏—Ç—å –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —à—É–º–∞ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–∏–ø—ã —à—É–º–∞ —Å –≤—ã—Å–æ–∫–æ–π –≤–∞—Ä–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å—é (–Ω–∞–ø—Ä–∏–º–µ—Ä, 'saltPepper', 'sparkle', 'white').");
      } else if (metrics.ssim < 30) {
        recs.push("–°—Ç—Ä—É–∫—Ç—É—Ä–Ω–æ–µ –æ—Ç–ª–∏—á–∏–µ –æ—á–µ–Ω—å –≤–µ–ª–∏–∫–æ (SSIM < 30%). –®—É–º –æ—á–µ–Ω—å –∞–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–π.");
      }

      // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ PSNR (Peak Signal-to-Noise Ratio)
      if (metrics.psnr > 30) {
        recs.push("PSNR –≤—ã—Å–æ–∫–∏–π (> 30 –¥–ë) ‚Äî –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –º–∞–ª–æ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç –æ—Ä–∏–≥–∏–Ω–∞–ª–∞. –£–≤–µ–ª–∏—á—å—Ç–µ —É—Ä–æ–≤–µ–Ω—å —à—É–º–∞ –∏–ª–∏ –ø—Ä–∏–º–µ–Ω–∏—Ç–µ —Ü–≤–µ—Ç–Ω–æ–π —à—É–º.");
      } else if (metrics.psnr < 20) {
        recs.push("PSNR –Ω–∏–∑–∫–∏–π (< 20 –¥–ë) ‚Äî —à—É–º –æ—á–µ–Ω—å —Å–∏–ª—å–Ω—ã–π.");
      }

      // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ RMSE (Root Mean Square Error)
      if (metrics.rmse > 80) {
        recs.push("RMSE –æ—á–µ–Ω—å –≤—ã—Å–æ–∫–∏–π (> 80) ‚Äî —à—É–º –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –º–µ–Ω—è–µ—Ç —è—Ä–∫–æ—Å—Ç—å –ø–∏–∫—Å–µ–ª–µ–π.");
      } else if (metrics.rmse < 20) {
        recs.push("RMSE –Ω–∏–∑–∫–∏–π (< 20) ‚Äî –∏–∑–º–µ–Ω–µ–Ω–∏—è –º–µ–∂–¥—É –æ—Ä–∏–≥–∏–Ω–∞–ª–æ–º –∏ —à—É–º–æ–≤—ã–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã. –£—Å–∏–ª—å—Ç–µ —à—É–º –∏–ª–∏ –∏–∑–º–µ–Ω–∏—Ç–µ —Ç–∏–ø.");
      }

      // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ MAE (Mean Absolute Error)
      if (metrics.mae > 60) {
        recs.push("MAE –≤—ã—à–µ 60 ‚Äî —Å—Ä–µ–¥–Ω–µ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –≤–µ–ª–∏–∫–æ. –®—É–º —Å–∏–ª—å–Ω–æ –≤–ª–∏—è–µ—Ç –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.");
      } else if (metrics.mae < 10) {
        recs.push("MAE –Ω–∏–∂–µ 10 ‚Äî —Ä–∞–∑–ª–∏—á–∏—è –ø–æ—á—Ç–∏ –Ω–µ–∑–∞–º–µ—Ç–Ω—ã. –£–≤–µ–ª–∏—á—å—Ç–µ –≤–µ—Å —Å–ª–æ—è –∏–ª–∏ –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —à—É–º–∞.");
      }

      // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ AE (Average Error)
      if (Math.abs(metrics.ae) > 50) {
        recs.push("AE (—Å—Ä–µ–¥–Ω—è—è —Ä–∞–∑–Ω–∏—Ü–∞) –±–æ–ª—å—à–µ 50 ‚Äî —à—É–º —Å–º–µ—â–∞–µ—Ç —è—Ä–∫–æ—Å—Ç—å –≤ —Å—Ç–æ—Ä–æ–Ω—É —Å–≤–µ—Ç–ª—ã—Ö –∏–ª–∏ —Ç–µ–º–Ω—ã—Ö —Ç–æ–Ω–æ–≤. –≠—Ç–æ –º–æ–∂–µ—Ç –ø–æ–≤–ª–∏—è—Ç—å –Ω–∞ –≤–æ—Å–ø—Ä–∏—è—Ç–∏–µ.");
      } else if (metrics.ae === 0) {
        recs.push("AE —Ä–∞–≤–µ–Ω 0 ‚Äî —à—É–º –Ω–µ –≤–ª–∏—è–µ—Ç –Ω–∞ –æ–±—â—É—é —è—Ä–∫–æ—Å—Ç—å. –≠—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ, –µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–π —à—É–º.");
      }

      // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ NCC (Normalized Cross-Correlation)
      if (metrics.ncc > 70) {
        recs.push("NCC –≤—ã—à–µ 70% ‚Äî –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å–∏–ª—å–Ω–æ –∫–æ—Ä—Ä–µ–ª–∏—Ä—É—é—Ç. –°–Ω–∏–∑—å—Ç–µ —Å—Ö–æ–∂–µ—Å—Ç—å —Å –ø–æ–º–æ—â—å—é –±–æ–ª–µ–µ —Å–ª—É—á–∞–π–Ω–æ–≥–æ —à—É–º–∞ –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å–ª–æ—ë–≤.");
      } else if (metrics.ncc < 30) {
        recs.push("NCC –Ω–∏–∂–µ 30% ‚Äî –∫–æ—Ä—Ä–µ–ª—è—Ü–∏—è –º–∞–ª–∞. –≠—Ç–æ —Ö–æ—Ä–æ—à–æ, —á—Ç–æ–±—ã –¥–æ–±–∏—Ç—å—Å—è –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ–≥–æ –æ—Ç–ª–∏—á–∏—è –æ—Ç –æ—Ä–∏–≥–∏–Ω–∞–ª–∞.");
      }

      // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ Entropy (—ç–Ω—Ç—Ä–æ–ø–∏—è)
      if (metrics.entropy < 6) {
        recs.push("–≠–Ω—Ç—Ä–æ–ø–∏—è –Ω–∏–∑–∫–∞—è (< 6) ‚Äî —Ç–µ–∫—Å—Ç—É—Ä–∞ —à—É–º–∞ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å–ª—É—á–∞–π–Ω–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–∏–ø—ã —à—É–º–∞ —Å —Ö–∞–æ—Ç–∏—á–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π (–Ω–∞–ø—Ä–∏–º–µ—Ä, '–ò—Å–∫—Ä–∞', '–ë–µ–ª—ã–π', '–°–æ–ª—å-–ü–µ—Ä–µ—Ü').");
      } else if (metrics.entropy > 8) {
        recs.push("–≠–Ω—Ç—Ä–æ–ø–∏—è –≤—ã—Å–æ–∫–∞—è (> 8) ‚Äî —Ç–µ–∫—Å—Ç—É—Ä–∞ —à—É–º–∞ –æ—á–µ–Ω—å —Å–ª—É—á–∞–π–Ω–∞. –≠—Ç–æ –æ—Ç–ª–∏—á–Ω–æ –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è –º–∞—Å–∫–∏—Ä–æ–≤–∫–∏ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è.");
      }

      // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
      if (layers.length > 4) {
        recs.push("–£ –≤–∞—Å –±–æ–ª—å—à–µ 4 —Å–ª–æ—ë–≤ —à—É–º–∞. –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–º–µ–¥–ª—è—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ–±—ä–µ–¥–∏–Ω–∏—Ç—å —Å–ª–æ–∏ —Å –º–∞–ª—ã–º –≤–µ—Å–æ–º.");
      }

      recommendationsDiv.innerHTML = recs.length
        ? `–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:<br>‚Ä¢ ${recs.join('<br>‚Ä¢ ')}`
        : '–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã.';
    }

    function addLayer() {
      const newLayer = {
        id: Date.now(),
        noiseType: 'perlin',
        weight: 0.5,
        noiseLevel: 0.7,
        noiseScale: 50,
        smoothType: 'gaussian',
        smoothValue: 0,
        spots: 2,
        colorNoise: false,
        alphaLevel: 1
      };
      layers.push(newLayer);
      updateLayerUI();
      saveToHistory();
      generateNoise();
    }

    function removeLayer(id) {
      layers = layers.filter(layer => layer.id !== id);
      updateLayerUI();
      generateNoise();
      saveToHistory();
    }

    function updateSmoothInputAttributes(layerId, smoothType) {
      const input = document.querySelector(`#smoothValue-${layerId}`);
      const tooltip = input.parentElement.querySelector('.tooltip');
      if (smoothType === 'gaussian') {
        input.min = 0;
        input.max = 10;
        input.step = 0.1;
        tooltip.textContent = '–†–∞–¥–∏—É—Å –≥–∞—É—Å—Å–æ–≤–∞ —Ä–∞–∑–º—ã—Ç–∏—è (0‚Äì10)';
      } else if (smoothType === 'median') {
        input.min = 0;
        input.max = 5;
        input.step = 1;
        tooltip.textContent = '–†–∞–¥–∏—É—Å –º–µ–¥–∏–∞–Ω–Ω–æ–≥–æ —Ñ–∏–ª—å—Ç—Ä–∞ (0‚Äì5)';
      } else if (smoothType === 'bilateral') {
        input.min = 0;
        input.max = 5;
        input.step = 0.1;
        tooltip.textContent = '–°–∏–≥–º–∞ –±–∏–ª–∞—Ç–µ—Ä–∞–ª—å–Ω–æ–≥–æ —Ñ–∏–ª—å—Ç—Ä–∞ (0‚Äì5)';
      } else if (smoothType === 'anisotropic') {
        input.min = 0;
        input.max = 10;
        input.step = 0.1;
        tooltip.textContent = '–°–∏–ª–∞ –∞–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–æ–≥–æ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è (0‚Äì10)';
      } else if (smoothType === 'nonlocal') {
        input.min = 0;
        input.max = 5;
        input.step = 0.1;
        tooltip.textContent = '–°–∏–ª–∞ –Ω–µ–ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è (0‚Äì5)';
      } else if (smoothType === 'mean') {
        input.min = 0;
        input.max = 5;
        input.step = 1;
        tooltip.textContent = '–†–∞–¥–∏—É—Å —É—Å—Ä–µ–¥–Ω—è—é—â–µ–≥–æ —Ñ–∏–ª—å—Ç—Ä–∞ (0‚Äì5)';
      }
    }

    function updateLayerUI() {
      const layerList = document.getElementById('layerList');
      layerList.innerHTML = '';
      layers.forEach(layer => {
        const div = document.createElement('div');
        div.className = 'layer-item';
        div.innerHTML = `
          <div class="control-group">
            <label>–¢–∏–ø —à—É–º–∞</label>
            <select onchange="updateLayer(${layer.id}, 'noiseType', this.value)">
            <option value="perlin" ${layer.noiseType === 'perlin' ? 'selected' : ''}>–ü–µ—Ä–ª–∏–Ω–æ–≤—ã–π</option>
            <option value="simplex" ${layer.noiseType === 'simplex' ? 'selected' : ''}>–°–∏–º–ø–ª–µ–∫—Å–∞</option>
            <option value="fractal" ${layer.noiseType === 'fractal' ? 'selected' : ''}>–§—Ä–∞–∫—Ç–∞–ª—å–Ω—ã–π</option>
            <option value="cellular" ${layer.noiseType === 'cellular' ? 'selected' : ''}>–ö–ª–µ—Ç–æ—á–Ω—ã–π</option>
            <option value="worley" ${layer.noiseType === 'worley' ? 'selected' : ''}>–í–æ—Ä–ª–∏</option>
            <option value="voronoi" ${layer.noiseType === 'voronoi' ? 'selected' : ''}>–í–æ—Ä–æ–Ω–æ–π</option>
            <option value="billow" ${layer.noiseType === 'billow' ? 'selected' : ''}>–ë–∏–ª–ª–æ—É</option>
            <option value="ridged" ${layer.noiseType === 'ridged' ? 'selected' : ''}>–†–∏–¥–∂–µ–¥</option>
            <option value="white" ${layer.noiseType === 'white' ? 'selected' : ''}>–ë–µ–ª—ã–π</option>
            <option value="pink" ${layer.noiseType === 'pink' ? 'selected' : ''}>–†–æ–∑–æ–≤—ã–π</option>
            <option value="brown" ${layer.noiseType === 'brown' ? 'selected' : ''}>–ö–æ—Ä–∏—á–Ω–µ–≤—ã–π</option>
            <option value="blue" ${layer.noiseType === 'blue' ? 'selected' : ''}>–°–∏–Ω–∏–π</option>
            <option value="saltPepper" ${layer.noiseType === 'saltPepper' ? 'selected' : ''}>–°–æ–ª—å-–ø–µ—Ä–µ—Ü</option>
            <option value="gaussian" ${layer.noiseType === 'gaussian' ? 'selected' : ''}>–ì–∞—É—Å—Å–æ–≤</option>
            <option value="gradient" ${layer.noiseType === 'gradient' ? 'selected' : ''}>–ì—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π</option>
            <option value="sparkle" ${layer.noiseType === 'sparkle' ? 'selected' : ''}>–ò—Å–∫—Ä—ã</option>
            <option value="impulse" ${layer.noiseType === 'impulse' ? 'selected' : ''}>–ò–º–ø—É–ª—å—Å–Ω—ã–π</option>
            <option value="stripe" ${layer.noiseType === 'stripe' ? 'selected' : ''}>–ü–æ–ª–æ—Å–∞—Ç—ã–π</option>
            <option value="turbulent" ${layer.noiseType === 'turbulent' ? 'selected' : ''}>–¢—É—Ä–±—É–ª–µ–Ω—Ç–Ω—ã–π</option>
            <option value="multilayerPerlin" ${layer.noiseType === 'multilayerPerlin' ? 'selected' : ''}>–ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤—ã–π –ü–µ—Ä–ª–∏–Ω</option>
            <option value="diamondSquare" ${layer.noiseType === 'diamondSquare' ? 'selected' : ''}>–ê–ª–º–∞–∑–Ω—ã–π –∫–≤–∞–¥—Ä–∞—Ç</option>
            <option value="ridgedMultifractal" ${layer.noiseType === 'ridgedMultifractal' ? 'selected' : ''}>–†–∏–¥–∂–µ–¥ –ú—É–ª—å—Ç–∏—Ñ—Ä–∞–∫—Ç–∞–ª</option>
            <option value="midpointDisplacement" ${layer.noiseType === 'midpointDisplacement' ? 'selected' : ''}>–°–º–µ—â–µ–Ω–∏–µ —Å—Ä–µ–¥–Ω–µ–π —Ç–æ—á–∫–∏</option>
            <option value="voronoiRidged" ${layer.noiseType === 'voronoiRidged' ? 'selected' : ''}>–í–æ—Ä–æ–Ω–æ–π –†–∏–¥–∂–µ–¥</option>
            <option value="wavelet" ${layer.noiseType === 'wavelet' ? 'selected' : ''}>–í–µ–π–≤–ª–µ—Ç</option>
            <option value="erosion" ${layer.noiseType === 'erosion' ? 'selected' : ''}>–≠—Ä–æ–∑–∏—è</option>
            <option value="flow" ${layer.noiseType === 'flow' ? 'selected' : ''}>–ü–æ—Ç–æ–∫–∏</option>
            <option value="organic" ${layer.noiseType === 'organic' ? 'selected' : ''}>–û—Ä–≥–∞–Ω–∏—á–µ—Å–∫–∏–π</option>
            <option value="cloud" ${layer.noiseType === 'cloud' ? 'selected' : ''}>–û–±–ª–∞–∫–∞</option>
            <option value="lava" ${layer.noiseType === 'lava' ? 'selected' : ''}>–õ–∞–≤–∞</option>
            <option value="fabric" ${layer.noiseType === 'fabric' ? 'selected' : ''}>–¢–∫–∞–Ω—å</option>
          </select>
            <span class="tooltip">–¢–∏–ø —à—É–º–∞ –¥–ª—è —Å–ª–æ—è</span>
          </div>
          <div class="control-group">
            <label>–í–ª–∏—è–Ω–∏–µ —Å–ª–æ—è</label>
            <input type="number" value="${layer.weight}" min="0" max="1" step="0.01" onchange="updateLayer(${layer.id}, 'weight', this.value)" />
            <span class="tooltip">–í–ª–∏—è–Ω–∏–µ —Å–ª–æ—è –Ω–∞ –∏—Ç–æ–≥–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (0‚Äì1)</span>
          </div>
          <div class="control-group">
            <label>–ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å</label>
            <input type="number" value="${layer.noiseLevel}" min="0" max="1" step="0.01" onchange="updateLayer(${layer.id}, 'noiseLevel', this.value)" />
            <span class="tooltip">–û–±—â–∞—è –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —à—É–º–∞ —Å–ª–æ—è</span>
          </div>
          <div class="control-group">
            <label>–ú–∞—Å—à—Ç–∞–± —à—É–º–∞</label>
            <input type="number" value="${layer.noiseScale}" min="1" max="100" step="1" onchange="updateLayer(${layer.id}, 'noiseScale', this.value)" />
            <span class="tooltip">–†–∞–∑–º–µ—Ä –¥–µ—Ç–∞–ª–µ–π —à—É–º–∞</span>
          </div>
          <div class="control-group">
            <label>–¢–∏–ø —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è</label>
            <select onchange="updateLayer(${layer.id}, 'smoothType', this.value); updateSmoothInputAttributes(${layer.id}, this.value)">
              <option value="gaussian" ${layer.smoothType === 'gaussian' ? 'selected' : ''}>–ì–∞—É—Å—Å–æ–≤–æ</option>
              <option value="median" ${layer.smoothType === 'median' ? 'selected' : ''}>–ú–µ–¥–∏–∞–Ω–Ω–æ–µ</option>
              <option value="bilateral" ${layer.smoothType === 'bilateral' ? 'selected' : ''}>–ë–∏–ª–∞—Ç–µ—Ä–∞–ª—å–Ω–æ–µ</option>
              <option value="anisotropic" ${layer.smoothType === 'anisotropic' ? 'selected' : ''}>–ê–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–æ–µ</option>
              <option value="nonlocal" ${layer.smoothType === 'nonlocal' ? 'selected' : ''}>–ù–µ–ª–æ–∫–∞–ª—å–Ω–æ–µ</option>
              <option value="mean" ${layer.smoothType === 'mean' ? 'selected' : ''}>–£—Å—Ä–µ–¥–Ω—è—é—â–µ–µ</option>
            </select>
            <span class="tooltip">–¢–∏–ø —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è –¥–ª—è —Å–ª–æ—è</span>
          </div>
          <div class="control-group">
            <label>–°–∏–ª–∞ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è</label>
            <input id="smoothValue-${layer.id}" type="number" value="${layer.smoothValue}" onchange="updateLayer(${layer.id}, 'smoothValue', this.value)" />
            <span class="tooltip">–†–∞–¥–∏—É—Å –∏–ª–∏ —Å–∏–ª–∞ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è</span>
          </div>
          <div class="control-group">
            <label>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—è—Ç–µ–Ω</label>
            <input type="number" value="${layer.spots}" min="0" max="100" step="1" onchange="updateLayer(${layer.id}, 'spots', this.value)" />
            <span class="tooltip">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—è—Ç–µ–Ω –¥–ª—è –º–∞—Å–∫–∏</span>
          </div>
          <div class="control-group">
            <label>–¶–≤–µ—Ç–Ω–æ–π —à—É–º</label>
            <input type="checkbox" ${layer.colorNoise ? 'checked' : ''} onchange="updateLayer(${layer.id}, 'colorNoise', this.checked)" />
            <span class="tooltip">–í–∫–ª—é—á–∏—Ç—å RGB-—à—É–º</span>
          </div>
          <div class="control-group">
            <label>–ê–ª—å—Ñ–∞-–∫–∞–Ω–∞–ª</label>
            <input type="number" value="${layer.alphaLevel}" min="0" max="1" step="0.01" onchange="updateLayer(${layer.id}, 'alphaLevel', this.value)" />
            <span class="tooltip">–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å —Å–ª–æ—è (0‚Äì1)</span>
          </div>
          <div class="control-group">
            <label>–£–¥–∞–ª–∏—Ç—å —Å–ª–æ–π</label>
            <button onclick="removeLayer(${layer.id})">üóëÔ∏è –£–¥–∞–ª–∏—Ç—å</button>
            <span class="tooltip">–£–¥–∞–ª—è–µ—Ç —Å–ª–æ–π</span>
          </div>
        `;
        layerList.appendChild(div);
        updateSmoothInputAttributes(layer.id, layer.smoothType);
      });
    }

    function updateLayer(id, key, value) {
      const layer = layers.find(l => l.id === id);
      if (layer) {
        layer[key] = key === 'colorNoise' ? value : key === 'smoothType' ? value : +value || value;
        generateNoise();
        saveToHistory();
      }
    }

    function saveToHistory() {
      history = history.slice(0, historyIndex + 1);
      history.push({
        layers: JSON.parse(JSON.stringify(layers)),
        canvasData: ctx.getImageData(0, 0, canvas.width, canvas.height)
      });
      historyIndex++;
      if (history.length > 50) {
        history.shift();
        historyIndex--;
      }
    }

    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        const state = history[historyIndex];
        layers = JSON.parse(JSON.stringify(state.layers));
        ctx.putImageData(state.canvasData, 0, 0);
        updateLayerUI();
      }
    }

    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        const state = history[historyIndex];
        layers = JSON.parse(JSON.stringify(state.layers));
        ctx.putImageData(state.canvasData, 0, 0);
        updateLayerUI();
      }
    }

    async function generateNoise(preview = false) {
      try {
        const startTime = performance.now();
        const widthInput = +document.getElementById('width').value;
        const heightInput = +document.getElementById('height').value;
        const width = preview ? Math.min(widthInput, 256) : widthInput;
        const height = preview ? Math.min(heightInput, 256) : heightInput;
        resizeCanvas(width, height);
        const colorPalette = document.getElementById('colorPalette').value;

        progress.style.display = 'block';
        progress.textContent = '–û–±—Ä–∞–±–æ—Ç–∫–∞: 0%';
        ctx.clearRect(0, 0, width, height);

        const finalImageData = ctx.createImageData(width, height);
        const chunkSize = Math.ceil(height / 10);

        for (let layer of layers) {
          const chunkImageData = await new Promise((resolve, reject) => {
            noiseWorker.onmessage = function (e) {
              const { data, width, height } = e.data;
              const imgData = new ImageData(data, width, height);
              resolve(imgData);
            };
            noiseWorker.onerror = function (e) {
              reject(new Error('–û—à–∏–±–∫–∞ –≤ Web Worker: ' + e.message));
            };
            noiseWorker.postMessage({
              width,
              height,
              layer: {
                ...layer,
                noiseLevel: layer.noiseLevel * (1 + Math.random() * 0.5), // –†–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏—è –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç–∏
                alphaLevel: Math.min(1, layer.alphaLevel * 1.2), // –£–≤–µ–ª–∏—á–µ–Ω–∏–µ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏
              },
              spots: layer.spots || 2,
              colorPalette,
            });
          });

          for (let i = 0; i < finalImageData.data.length; i += 4) {
            finalImageData.data[i] += chunkImageData.data[i] * (layer.weight * 1.5); // –£–≤–µ–ª–∏—á–µ–Ω–∏–µ –≤–µ—Å–∞
            finalImageData.data[i + 1] += chunkImageData.data[i + 1] * (layer.weight * 1.5);
            finalImageData.data[i + 2] += chunkImageData.data[i + 2] * (layer.weight * 1.5);
            finalImageData.data[i + 3] += chunkImageData.data[i + 3] * (layer.weight * 1.5);
          }

          for (let y = 0; y < height; y += chunkSize) {
            const chunkHeight = Math.min(chunkSize, height - y);
            const chunkData = ctx.createImageData(width, chunkHeight);
            for (let cy = 0; cy < chunkHeight; cy++) {
              for (let x = 0; x < width; x++) {
                const srcIndex = ((y + cy) * width + x) * 4;
                const dstIndex = (cy * width + x) * 4;
                chunkData.data[dstIndex] = finalImageData.data[srcIndex];
                chunkData.data[dstIndex + 1] = finalImageData.data[srcIndex + 1];
                chunkData.data[dstIndex + 2] = finalImageData.data[srcIndex + 2];
                chunkData.data[dstIndex + 3] = finalImageData.data[srcIndex + 3];
              }
            }
            ctx.putImageData(chunkData, 0, y);
            progress.textContent = `–û–±—Ä–∞–±–æ—Ç–∫–∞: ${Math.round((y + chunkHeight) / height * 100)}%`;
            await new Promise(resolve => requestAnimationFrame(resolve));
          }
        }

        ctx.putImageData(finalImageData, 0, 0);
        progress.style.display = 'none';


        const endTime = performance.now();
        const generationTime = (endTime - startTime).toFixed(2);

        const metrics = calculateMetrics(finalImageData, width, height);
        metricsDiv.textContent = `SSIM: ${metrics.ssim.toFixed(2)}%, PSNR: ${metrics.psnr.toFixed(2)} dB, RMSE: ${metrics.rmse.toFixed(2)}, MAE: ${metrics.mae.toFixed(2)}, AE: ${metrics.ae.toFixed(2)}, NCC: ${metrics.ncc.toFixed(2)}%, Entropy: ${metrics.entropy.toFixed(2)}, –í—Ä–µ–º—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: ${generationTime} –º—Å`; updateRecommendations(metrics, generationTime);

        saveToHistory();
      } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:', error);
        progress.textContent = '–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏';
        progress.style.display = 'block';
      }
    }

    async function previewNoise() {
      await generateNoise(true);
    }

    function download(name = 'noise.png') {
      const link = document.createElement('a');
      link.download = name;
      link.href = canvas.toDataURL();
      link.click();
    }

    async function saveCopies() {
      const count = +copiesInput.value || 5;
      progress.style.display = 'block';
      for (let i = 0; i < count; i++) {
        await generateNoise();
        progress.textContent = `–û–±—Ä–∞–±–æ—Ç–∫–∞: ${Math.round((i + 1) / count * 100)}%`;
        await new Promise(resolve => setTimeout(resolve, 100));
        download(`noise${i + 1}.png`);
      }
      progress.style.display = 'none';
    }

    function saveSettings() {
      const settings = {
        width: document.getElementById('width').value,
        height: document.getElementById('height').value,
        layers,
        colorPalette: document.getElementById('colorPalette').value,
        copies: copiesInput.value
      };
      const presetName = prompt('–í–≤–µ–¥–∏—Ç–µ –∏–º—è –ø—Ä–µ—Å–µ—Ç–∞:') || 'default';
      let presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      presets[presetName] = settings;
      localStorage.setItem('noisePresets', JSON.stringify(presets));
      alert('–ü—Ä–µ—Å–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω!');
    }

    function loadPresets() {
      const presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      const presetName = prompt('–í–≤–µ–¥–∏—Ç–µ –∏–º—è –ø—Ä–µ—Å–µ—Ç–∞ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏:\n–î–æ—Å—Ç—É–ø–Ω—ã–µ: ' + Object.keys(presets).join(', '));
      if (presets[presetName]) {
        const settings = presets[presetName];
        document.getElementById('width').value = settings.width || 512;
        document.getElementById('height').value = settings.height || 1024;
        document.getElementById('colorPalette').value = settings.colorPalette || '#ffffff';
        layers = settings.layers || [{
          id: Date.now(),
          noiseType: 'perlin',
          weight: 1,
          noiseLevel: 0.7,
          noiseScale: 10,
          smoothType: 'gaussian',
          smoothValue: 0,
          spots: 2,
          colorNoise: false,
          alphaLevel: 1
        }];
        copiesInput.value = settings.copies || 5;
        copiesDisplay.textContent = settings.copies || 5;
        updateLayerUI();
        generateNoise();
      } else {
        alert('–ü—Ä–µ—Å–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω!');
      }
    }

    copiesInput.addEventListener('input', () => {
      copiesDisplay.textContent = copiesInput.value;
    });

    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    const inputs = document.querySelectorAll('input, select');
    inputs.forEach(input => {
      input.addEventListener('input', debounce(generateNoise, 300));
    });

    window.addEventListener('resize', generateNoise);
    updateLayerUI();
    generateNoise();


    function openPresetModal() {
      document.getElementById("presetModal").style.display = "block";
      updatePresetList();
    }

    function closePresetModal() {
      document.getElementById("presetModal").style.display = "none";
    }

    document.getElementById("savePresetButton").addEventListener("click", function () {
      const nameInput = document.getElementById("presetNameInput");
      const presetName = nameInput.value.trim();
      if (!presetName) return;

      const settings = {
        width: document.getElementById('width').value,
        height: document.getElementById('height').value,
        layers,
        colorPalette: document.getElementById('colorPalette').value,
        copies: copiesInput.value
      };

      let presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      presets[presetName] = settings;
      localStorage.setItem('noisePresets', JSON.stringify(presets));

      nameInput.value = '';
      updatePresetList();
    });

    function loadPreset(presetName) {
      const presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      const settings = presets[presetName];
      if (!settings) return;

      document.getElementById('width').value = settings.width || 512;
      document.getElementById('height').value = settings.height || 1024;
      document.getElementById('colorPalette').value = settings.colorPalette || '#ffffff';
      layers = settings.layers || getDefaultLayers();
      copiesInput.value = settings.copies || 5;
      copiesDisplay.textContent = settings.copies || 5;

      updateLayerUI();
      generateNoise();
      closePresetModal();
    }

    function deletePreset(presetName) {
      if (!confirm(`üóëÔ∏è –£–¥–∞–ª–∏—Ç—å –ø—Ä–µ—Å–µ—Ç "${presetName}"? –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ.`)) return;
      let presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      delete presets[presetName];
      localStorage.setItem('noisePresets', JSON.stringify(presets));
      updatePresetList();
    }

    function updatePresetList() {

      const listContainer = document.getElementById("presetList");
      listContainer.innerHTML = "";

      const presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      const sortedNames = Object.keys(presets).sort();

      sortedNames.forEach(name => {
        const card = document.createElement("div");
        card.className = "preset-card";

        const title = document.createElement("div");
        title.textContent = name;

        const loadBtn = document.createElement("button");
        loadBtn.textContent = "–ó–∞–≥—Ä—É–∑–∏—Ç—å";
        loadBtn.className = "load";
        loadBtn.onclick = () => loadPreset(name);

        const deleteBtn = document.createElement("button");
        deleteBtn.textContent = "üóëÔ∏è –£–¥–∞–ª–∏—Ç—å";
        deleteBtn.className = "delete";
        deleteBtn.onclick = () => deletePreset(name);

        card.appendChild(title);
        card.appendChild(loadBtn);
        card.appendChild(deleteBtn);
        listContainer.appendChild(card);
      });
    }

    document.getElementById("closeModal").addEventListener("click", closePresetModal);
    document.getElementById("openPresetModalButton").addEventListener("click", openPresetModal);
    window.onclick = function (event) {
      if (event.target == document.getElementById("presetModal")) closePresetModal();
    };

    function getDefaultLayers() {
      return [{
        id: Date.now(),
        noiseType: 'perlin',
        weight: 0.5,
        noiseLevel: 0.7,
        noiseScale: 50,
        smoothType: 'gaussian',
        smoothValue: 0,
        spots: 2,
        colorNoise: false,
        alphaLevel: 1
      }];
    }

    async function initializePresets() {
      if (!confirm(`–í—ã —Ç–æ—á–Ω–æ —Ö–æ—Ç–∏–µ –≤–µ—Ä–Ω—É—Ç—å –±–∞–∑–æ–≤—ã–µ –ø—Ä–µ—Å–µ—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ —É–¥–∞–ª–∏–ª–∏ —Ä–∞–Ω–µ–µ?`)) return;

      // –ó–∞–≥—Ä—É–∂–∞–µ–º –ø—Ä–µ—Å–µ—Ç—ã –∏–∑ JSON —Ñ–∞–π–ª–∞
      const response = await fetch('initializePresets.js');
      const defaultPresets = await response.json();

      // –ü–æ–ª—É—á–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –ø—Ä–µ—Å–µ—Ç—ã –∏–∑ localStorage –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º –ø—É—Å—Ç–æ–π –æ–±—ä–µ–∫—Ç
      let presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');

      // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–µ—Å–µ—Ç—ã –∏–∑ JSON –≤ –æ–±—ä–µ–∫—Ç presets
      defaultPresets.forEach(preset => {
        presets[preset.name] = preset;
      });

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –ø—Ä–µ—Å–µ—Ç—ã –≤ localStorage
      localStorage.setItem('noisePresets', JSON.stringify(presets));

      // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –ø—Ä–µ—Å–µ—Ç–æ–≤
      updatePresetList();

    }
  
  
  </script>
  <script src="initializePresets.js"></script>

</body>

</html>
